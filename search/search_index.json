{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>WCSharp is a powerful set of libraries for Warcraft III map development with C#. Write your map logic in C# and transpile it to Lua code that the game engine can understand.</p> <p>Why C#?</p> <ul> <li>Better Code: C# is natively object-oriented, enabling cleaner, more maintainable code.</li> <li>Type Safety: Static typing prevents bugs during development, without the need for EmmyLua annotations.</li> <li>IDE: Write Warcraft III map logic in Visual Studio.</li> <li>Built in Systems: WCSharp simplifies Warcraft III modding by providing pre-built systems for common tasks.</li> </ul>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Info</p> <p>Full installation instructions are available here.</p> <ol> <li>Download the WCSharp template.</li> <li>Open the solution and update NuGet packages.</li> <li>Set your Warcraft III executable path in <code>Launcher/app.config</code>.</li> <li>Move the included <code>Blizzard.j</code> and <code>common.j</code> files to <code>C:\\Users\\[Username]\\My Documents\\Warcraft III\\JassHelper</code>.</li> <li>Run the <code>Launcher</code> project.</li> </ol>"},{"location":"constant-generator/","title":"ConstantGenerator","text":"<p>The ConstantGenerator is a simple program that should be executed from that Launcher. It comes pre-built into the WCSharp template. When you run the constant generator, it will generate a number of files:</p> <ul> <li><code>Regions.cs</code> - Contains WCSharp Rectangle objects corresponding to the regions defined on your map. The Rectangle class has several methods and properties to simplify working with the regions.</li> <li><code>Cameras.cs</code> - Contains camerasetup objects corresponding to the cameras defined on your map.</li> <li><code>Constants.cs</code> - Contains constant integers for all of the custom units/spells, etc. (everything in the object editor) that you have added to your map. NOTE: the name must be different from the base object in order to detect it. If you want to use the original name of the object, please add or modify the editor suffix.</li> </ul>"},{"location":"constant-generator/#options","title":"Options","text":"<p>When running the constant generator, an options class can be passed along to specify how you want the constants to be generated. At present, these are the options available:</p> Name Description IncludeCode If true, includes the FourCC code in the generated name, i.e. \"ABILITY_A001_FAERIE_FIRE\" instead of \"ABILITY_FAERIE_FIRE\". Enabling this will prevent naming conflicts."},{"location":"desyncs/","title":"Desyncs","text":"<p>This page is primarily dedicated towards desyncs within the C# context. There are a lot of things that can cause desyncs, but for the more general ones I recommend looking at other online sources, such as this thread on Hiveworkshop.</p>"},{"location":"desyncs/#gethandleid","title":"GetHandleId","text":"<p>Do not use GetHandleId. Ever.</p> <p>This is a frequently used tool back from the JASS era, however it has zero use in lua and by extension C#. For dictionaries, you can simply map the handle itself rather than the handle id. Performance-wise this is at least as fast as using the handle id, and it ensures that if you forget to clean up any handle ids, no desyncs can occur.</p> <p>In simple terms:</p> <ul> <li>If you make a mistake using handles, you leak some memory.  </li> <li>If you make a mistake using handle ids, you desync the entire game!</li> </ul> <p>As such, it makes no sense to use GetHandleId within the context of C#/lua. Doing so exposes you to a number of risks while providing no advantages.</p>"},{"location":"desyncs/#dictionaryhashset-enumeration","title":"Dictionary/HashSet enumeration","text":"<p>This uses the lua <code>pairs</code> keyword in the background, which is prone to desyncing. You can use a SortedDictionary instead. Alternatively, you can also sort the results prior to enumerating, however...</p>"},{"location":"desyncs/#sorting","title":"Sorting","text":"<p>Lua does not have a stable sorting algorithm. For example, consider the following code:</p> <pre><code>record MyData(int Value, string Name);\n\nvar list = new List&lt;MyData&gt;\n{\n    new MyData(2, \"Foo\"),\n    new MyData(3, \"World\"),\n    new MyData(2, \"Bar\"),\n    new MyData(1, \"Hello\"),\n};\n\nlist = list.OrderBy(x =&gt; x.Value).ToList();\n// Possible output order:\n// [(1, \"Hello\"), (2, \"Foo\"), (2, \"Bar\"), (3, \"World\")]\n// [(1, \"Hello\"), (2, \"Bar\"), (2, \"Foo\"), (3, \"World\")]\n</code></pre> <p>This is a problem if we're intending to do anything with the <code>Name</code> property.</p> <p>The best way to address this problem is simply by ensuring that each time you perform a sort, there is only a single valid output:</p> <pre><code>list = list.OrderBy(x =&gt; x.Value).ThenBy(x =&gt; x.Name).ToList();\n</code></pre>"},{"location":"getting-started/","title":"Installation","text":"<p>WCSharp consists of a set of NuGet packages.</p>"},{"location":"getting-started/#requirements","title":"Requirements","text":"<p>WCSharp requires a C# development environment for .NET 6. If you're unfamiliar with the C# ecosystem we recommend installing Visual Studio 2022.</p> <p></p> <p>When installing Visual Studio, make sure to select the \".NET Desktop Development\" workload.</p> <p>If you've installed Visual Studio previously you can launch the Visual Studio Installer and modify your installation instead.</p> <p>Note</p> <p>WCSharp is built for .NET 6 and requires Visual Studio 17.0 or higher.</p>"},{"location":"getting-started/#wcsharp-template","title":"WCSharp Template","text":"<p>The easiest way to install WCSharp is to download the WCSharp template. This is a scaffold project that sets you up with everything you need for C# mapmaking.</p> <ul> <li>A preconfigured Warcraft III map.</li> <li>A Visual Studio solution with a Launcher and a Source project.</li> <li>A .gitignore file for source control.</li> </ul>"},{"location":"getting-started/#structure","title":"Structure","text":"<pre><code>WCSharpTemplate\n\u251c\u2500\u2500 Launcher                    --- Launcher Project (compiles the map)\n\u2502   \u251c\u2500\u2500 app.config\n\u2502   \u251c\u2500\u2500 Program.cs\n\u2502   \u2514\u2500\u2500 Launcher.csproj\n\u251c\u2500\u2500 Source                      --- Source Project (where you write your C# map code)\n\u2502   \u251c\u2500\u2500 Constants.cs\n\u2502   \u251c\u2500\u2500 Program.cs\n\u2502   \u2514\u2500\u2500 Source.csproj\n\u251c\u2500\u2500 artifacts                   --- Artifacts (the compilation output)\n\u2502   \u251c\u2500\u2500 war3map.lua\n\u2502   \u2514\u2500\u2500 target.w3x\n\u251c\u2500\u2500 source.w3x                  --- Warcraft III Map (saved as folder)\n\u2502   \u2514\u2500\u2500 [war3map files]\n\u2514\u2500\u2500 WCSharpTemplate.sln         --- Solution File\n</code></pre>"},{"location":"getting-started/#setup","title":"Setup","text":"<p>Before launching the template, a few configuration steps are required.</p> <ol> <li>Open <code>WCSharpTemplate.sln</code> with Visual Studio.</li> <li>Right click the <code>Launcher</code> project and select <code>Set as Startup Project</code>.</li> <li>Right click the <code>Launcher</code> project and click <code>Manage NuGet Packages</code>. Update all packages. Do the same for the <code>Source</code> project.</li> <li>Set the path the Warcraft III executable path in <code>Launcher/app.config</code> is correct.</li> <li>Move the included <code>Blizzard.j</code> and <code>common.j</code> files to <code>C:\\Users\\YourUserName\\My Documents\\Warcraft III\\JassHelper</code>. Create the <code>JassHelper</code> folder if it doesn't exist.</li> <li>Run the <code>Launcher</code> project in Visual Studio.</li> <li>You will be provided with three options, select the third option to compile and run the map.</li> </ol>"},{"location":"release-notes/","title":"Release Notes","text":""},{"location":"release-notes/#2024-08-02","title":"2024-08-02","text":"<ul> <li>Add GetRandomAnglel, GetRandomAngleRad and IsInRange to Util.</li> <li>Allow for WCSharp.Missile.RunCollisions to be overridden.</li> <li>Change WCSharp.Missiles and WCSharp.Buffs to only skip effect creation if <code>EffectString</code> is null, rather than if null or empty string.</li> </ul>"},{"location":"release-notes/#2024-03-27","title":"2024-03-27","text":"<ul> <li>Add SmoothTrigger and SmoothDisposableTrigger to WCSharp.Events.</li> </ul>"},{"location":"release-notes/#2024-03-01-v300","title":"2024-03-01 (v3.0.0)","text":"<ul> <li>Add new WCSharp.Api package.</li> <li>Update all packages to utilise WCSharp.Api instead of War3Api.</li> <li>Fixed the speed of orbital projectiles being incorrect.</li> <li>Remove all instances of GetHandleId from WCSharp packages to prevent potential desyncs.</li> <li>Fixed an issue where unregistering one event could cause it to unregister all grouped events.</li> <li>Add a TypeWrapper class to WCSharp.Shared which acts as a solution to reflection-based type checking of WC3 types. For more information, see the package page.</li> </ul>"},{"location":"release-notes/#2023-09-24-v220","title":"2023-09-24 (v2.2.0)","text":"<ul> <li>Add new WCSharp.W3MMD package.</li> <li>Periodic events and intervals on buffs and missiles will now potentially tick multiple times in a single frame if the interval is less than a single tick.</li> <li>Made many previously internal fields on missiles public properties instead so they can be more easily used for new implementations or those who just prefer radians.</li> <li>Each missile now has a set of flight modes to better control how they handle terrain.</li> <li>Replaced the Disable/ReactivateArc methods on basic and curve missiles with a property that handles the logic automatically.</li> <li>Change Lightning and Missile system to handle Z coordinate retrieval via a new static method in Shared.Util.</li> <li>Added an auto generated documentation based on the Visual Studio XML documentation.</li> </ul>"},{"location":"release-notes/#2023-03-31","title":"2023-03-31","text":"<ul> <li>Fixed an off-by-one error when sending messages across the SyncSystem. If your save just happened to be <code>(240*x)+1</code> characters long, it would generate an invalid message.</li> </ul>"},{"location":"release-notes/#2023-03-24","title":"2023-03-24","text":"<ul> <li>Fixed a potential desync when retrieving a synced DateTime.</li> <li>Changed the EnableDebug methods to log both the exception message and the stack trace, instead of just the message.</li> </ul>"},{"location":"release-notes/#2023-03-03","title":"2023-03-03","text":""},{"location":"release-notes/#wcsharpshared","title":"WCSharp.Shared","text":"<ul> <li>Added new extension methods for group enumeration: <code>FirstOrDefault</code>, <code>ToList</code> and <code>ToHashSet</code>. These methods use a faster way of enumerating a group, but also they don't use the slower yield enumeration. In practice, they are always faster than the old <code>Enumerate</code> which is marked as obsolete for now.</li> <li>Improved the performance of the <code>Heal</code> unit extension method.</li> <li>The other packages have been updated to utilise these new extension methods where applicable.</li> </ul>"},{"location":"release-notes/#2023-02-11","title":"2023-02-11","text":""},{"location":"release-notes/#wcsharpsaveload","title":"WCSharp.SaveLoad","text":"<ul> <li>Adding additional ability ids for storage is now done via a new <code>SaveSystem</code> instead of <code>SaveSystem&lt;T&gt;</code>.</li> <li>Default data storage capacity has been increased from 2000 to 6000 characters.</li> <li>Storage space warning has been moved from 50% to 75% of capacity.</li> </ul>"},{"location":"release-notes/#2023-02-11_1","title":"2023-02-11","text":""},{"location":"release-notes/#wcsharpdatetime","title":"WCSharp.DateTime","text":"<ul> <li>Fixed the <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code> and <code>&lt;=</code> operators for WcDateTime and WcTimeSpan not handling null values correctly.</li> <li>Fixed <code>CompareTo</code> for WcDateTime and WcTimeSpan not handling null values correctly.</li> </ul>"},{"location":"release-notes/#wcsharpshared_1","title":"WCSharp.Shared","text":"<ul> <li>Fixed the <code>==</code> and <code>!=</code> operators for Point and Rectangle not handling null values correctly.</li> </ul>"},{"location":"release-notes/#wcsharpsaveload_1","title":"WCSharp.SaveLoad","text":"<ul> <li>Fixed multiple SaveLoad systems of the same generic type firing each others event handlers. Meaning, if you create two instances of <code>SaveSystem&lt;MySave&gt;</code> and try to load a save on one of them, only the one that you're loading from will fire its event, instead of both.</li> <li>Fixed the HashCode comparing the HashCode that it uses to verify save integrity by re-serializing the save file instead of just taking the save string as-is. This could cause it to believe that the save was tampered with if the class file was changed, or if it used dictionaries/hashsets with no guaranteed order.</li> </ul>"},{"location":"release-notes/#2022-12-24","title":"2022-12-24","text":""},{"location":"release-notes/#wcsharpjson","title":"WCSharp.Json","text":"<ul> <li>Removed a leftover debug output</li> <li>Fixed HashSets with primitive values not serialising correctly</li> <li>Fixed Dictionaries not serialising correctly after a CSharpLua update</li> </ul>"},{"location":"release-notes/#wcsharpsaveload_2","title":"WCSharp.SaveLoad","text":"<p>OnSaveLoaded now returns an enum indicating the state of the save loaded instead of just a boolean. Previously it wasn't possible to determine whether a new save was returned because it failed to load an existing save, or whether the player simply had no save file. This value can now be used to determine that, so that you can potentially warn a player whose save failed to load that continuing to play will cause their save file to be reset.</p>"},{"location":"release-notes/#2022-12-23-v210","title":"2022-12-23 (v2.1.0)","text":"<ul> <li>Start of this documentation.</li> <li>Upgraded all packages to 2.1.0.</li> <li>Upgraded to .NET 6.</li> </ul>"},{"location":"release-notes/#wcsharpevents","title":"WCSharp.Events","text":"<p>Player unit events rewritten to improve clarity, support single-source events and support listening to the same event multiple times.</p>"},{"location":"release-notes/#prior-updates","title":"Prior updates","text":"<p>Version 1.x were the early single-package version, with a special WCSharp.SaveLoad v1.4 for backwards compatibility with old saves. Version 2.0.x were split-package versions for .NET 5.</p>"},{"location":"upgrading-to-war3net-v5.x/","title":"Upgrading to War3Net v5.x","text":"<p>If you want to upgrade an existing map that uses WCSharp from War3Net 3.x to 5.x, there's a few things you'll have to do. I'd say that there is an easy and a hard way, and I'll go over them both.  </p> <p>Note that for either approach, you'll still need to address breaking changes from WCSharp v2. This should primarily be addressing the changes made to the buff system, as well as the namespace change from Utils to Shared (I recommend a find &amp; replace using Visual Studio or Notepad++ for that part).</p>"},{"location":"upgrading-to-war3net-v5.x/#the-easy-route","title":"The easy route","text":"<p>I personally recommend the easy route, which is to copy over the entirety of the WCSharp template, and just copy/paste the <code>.cs</code> files of your own Source project into the template, as well as your <code>source.w3x</code> folder. All the WCSharp packages come pre-installed on this template, and your build chain should be good right away. If you were using the old Save/Load system, you'll want to open up NuGet Package Manager and downgrade WCSharp.SaveLoad to v1.4.0.</p>"},{"location":"upgrading-to-war3net-v5.x/#the-hard-route","title":"The hard route","text":"<p>If you don't want to use the template for some reason, you'll have to go the long route. I will try to go over the steps:</p> <ol> <li>In your project properties (for both launcher/source), set the \"Target framework\" to \".NET 5.0\"</li> <li>You'll need to update your Launcher's <code>Program.cs</code> considerably. If you want you can try and figure it out using the War3Net's template, but personally I recommend just copying the entirety of the WCSharp template for this part.</li> <li>Uninstall WCSharp, then install all individual WCSharp packages. If you were using the Save/Load system, you'll probably want to install WCSharp.SaveLoad v1.4.0 instead of v2.</li> </ol>"},{"location":"wcsharp/api/","title":"WCSharp.Api","text":"<p>WCSharp v3.0 offers a new API to replace the default War3Api that comes with War3Net.</p> <p>The WCSharp API essentially behaves as a wrapper around WC3 handles, allowing you to interact with them in a more natural way:</p> <pre><code>// War3Api\nvar unit = CreateUnit(\"hfoo\", Player(0), 0, 0, 270); // Create a unit\nSetUnitState(unit, UNIT_STATE_MANA, GetUnitState(unit, UNIT_STATE_MANA) + 50); // Increase its mana by 50\nKillUnit(unit); // Kill the unit\n\n// WCSharp.Api\nvar unit = unit.Create(\"hfoo\", Player(0), 0, 0, 270); // constructor support will be added in the future, there's a bug with CSharpLua for the time being\nunit.Mana += 50;\nunit.Kill();\n</code></pre> <p>Thanks to CSharpLua templates, despite behaving more like C# objects than WC3 handles, these two pieces of code produce the exact same code, but the latter is significantly easier and more intuitive to write.  </p> <p>Methods and properties exist for almost all WC3 handles that you are likely to use in a project, but if need be you can always fall back to War3Api style code. The WCSharp API still has the entire <code>Common.j</code> and <code>Blizzard.j</code> accessible via <code>WCSharp.Api.Common</code> and <code>WCSharp.Api.Blizzard</code>, allowing you to use the same style if need be to access all of WC3's functionality. This also makes it simple to transition a project from War3Api to WCSharp.</p>"},{"location":"wcsharp/api/#transitioning-from-war3api-to-wcsharpapi","title":"Transitioning from War3Api to WCSharp.Api","text":"<p>If you are starting a new project, you can simply use the WCSharp template to get started.</p> <p>The procedure isn't the cleanest, but it's fairly simple regardless. The process is as follows:</p> <ul> <li>In your \"Launcher\" project, use NuGet to install <code>WCSharp.CSharpLua.CoreSystem</code>. Additionally, ensure that <code>War3Net.CSharpLua</code> is at least version 2.0.0.</li> <li>In your \"Source\" project, use NuGet to install WCSharp.Api.</li> <li>In your \"Source\" project, use NuGet to install the v3.x versions of any WCSharp packages you are using.</li> <li>Use some text editing tool (e.g. Notepad++) to mass replace <code>using static War3Api.Common;</code> with <code>using WCSharp.Api;\\r\\nusing static WCSharp.Api.Common;</code>.</li> <li>In your \"Launcher/Program.cs\" file, adjust the part that loads the core system files as such:</li> </ul> <pre><code>// Old\nvar coreSystemFiles = CSharpLua.CoreSystem.CoreSystemProvider.GetCoreSystemFiles();\n\n// New\nvar coreSystemFiles = CSharpLua.CoreSystem.CoreSystemProvider.GetCoreSystemFiles()\n    .Where(x =&gt; !x.EndsWith(\"Common.lua\"))\n    .Concat(new[] { \"CoreSystem/WCSharp.lua\" });\n</code></pre>"},{"location":"wcsharp/api/#tips-tricks","title":"Tips &amp; tricks","text":"<ul> <li>Remember that you can always use War3Api style code by simply adding a static import to <code>WCSharp.Api.Common</code>.</li> <li>All event-related information is centered in the <code>@event</code> class, e.g. <code>@event.Unit</code> is identical to <code>GetTriggerUnit();</code>.</li> <li>Whenever you need to clean something up to prevent a memory leak, simply call its <code>Dispose</code> method. All actions that remove, destroy or otherwise get rid of a WC3 handle has been unified under <code>IDisposable</code> implementations. Due to a bug with CSharpLua however, you should not use <code>using var</code> on WC3 handles for now.</li> <li>Ability fields provide detailed information regarding which fields they're used in via IntelliSense, allowing you to more easily find which field you should be editing.</li> </ul>"},{"location":"wcsharp/api/#things-to-keep-in-mind","title":"Things to keep in mind","text":"<p>There are a few things to keep in mind when using the WCSharp API.</p> <ol> <li> <p>The API is still in an early state. Although it is already feature complete and more than ready for use, please keep in mind that not everything will be perfect and that there may be breaking changes in the future. Feel free to suggest improvements!</p> </li> <li> <p>Because the API is entirely template based, there is no actual C# object, and retrieving any value is invoking a WC3 native. If you intend to use a property multiple times, you should assign it to a variable to avoid multiple native calls!</p> </li> <li> <p>There are some properties that do result in multiple natives being invoked. This is because the actions are simply not possible with a single native call, but they were added to the WCSharp API for convenience. In most cases, this is not important, but if you intend to use these properties very frequently, you may wish to take this into account. These actions are as follows:</p> <ul> <li>camerasetup.X.set</li> <li>camerasetup.Y.set</li> <li>item.X.set</li> <li>item.Y.set</li> <li>lightning.Red.set</li> <li>lightning.Green.set</li> <li>lightning.Blue.set</li> <li>lightning.Alpha.set</li> <li>rect.MinX.set</li> <li>rect.MinY.set</li> <li>rect.MaxX.set</li> <li>rect.MaxY.set</li> <li>rect.CenterX.set</li> <li>rect.CenterY.set</li> <li>unit.SkillPoints.set</li> <li>unit.WaygateDestinationX.set</li> <li>unit.WaygateDestinationY.set</li> <li>unit.AttackRange1.set</li> <li>unit.AttackRange2.set</li> </ul> </li> </ol>"},{"location":"wcsharp/libraries/date-time/","title":"WCSharp.DateTime","text":"<p>Use of this package requires that the compilers IsExportMetadata property is set to true.</p> <p>Thanks to Lua having the option to retrieve the OS time, WCSharp is able to retrieve the time for each player and use them to acquire a synchronised time for all players. However, unlike the C# built-in types of DateTime and TimeSpan, Lua's precision only goes to seconds instead of ticks, and Warcraft III is currently unable to even perform 64-bit calculations.</p> <p>As a result, even if we can retrieve the current time, DateTime and TimeSpan cannot be used.</p> <p>This is where WCSharp.DateTime comes in, as it recreates both DateTime and TimeSpan in a Warcraft III/Lua compliant fashion. As such, for the most part I recommend reading the official documentation on DateTime and TimeSpan if you want more basic information on their functionality.</p>"},{"location":"wcsharp/libraries/date-time/#local-time","title":"Local time","text":"<p>Getting a players local time is very easy to retrieve, simply use <code>WcDateTime.LocalTime</code> or <code>WcDateTime.LocalTimeUtc</code>. However, note that this is only the time for the local player! If you're confused about what I'm saying, then you definitely don't want to use this. The local time is different for each player, and using it recklessly will result in a desync.</p> <p>If we want a timestamp that is safe to use under all circumstances, we need a timestamp that is the same for all players: a synchronised time.</p>"},{"location":"wcsharp/libraries/date-time/#synchronization","title":"Synchronization","text":"<p>Synchronization of time is performed via the <code>WcDateTime.GetCurrentTime</code> method. Since retrieving a synchronised time is a process that cannot be instantly completed, a callback must be supplied which will receive the WcDateTime once it has been calculated.</p> <p>Behind the scenes, the times of all players retrieved individually and collected using WCSharp.Sync, after which a synchronised time is decided via the supplied <code>DateTimeSyncMethod</code> enum. The following methods are supported for this:</p> Name Description Earliest Picks the earliest time among all players. Latest Picks the latest time among all players. Average Picks the average time of all players. BestFit Default. Picks a time that minimizes the time difference of the chosen time compared to that of all players. In practice, this means it will pick the middle player on uneven player counts, or the average of the middle two players on even player counts. <p>For retrieving updated timestamps after initial calculation, the <code>WcDateTime.TryGetCurrentTime</code> method is a useful option. This will return the current synchronised WcDateTime immediately using results of earlier requests if possible.</p>"},{"location":"wcsharp/libraries/dummies/","title":"WCSharp.Dummies","text":"<p>Attention</p> <p>In order to use the dummy system, you MUST have a Dummy unit type with the unit ID of \"xxxx\" (2021161080). The WCSharp comes with this dummy by default. For more information on dummies, please take a look at related threads on Hiveworkshop.</p> <p>The dummy system offers the following features:</p> <ul> <li>Provides a simple means of acquiring a dummy</li> <li>Recycles dummies after they are no longer in use, thus saving memory and preventing leaks</li> <li>Automatically removes spells from dummies after they've cast it</li> </ul>"},{"location":"wcsharp/libraries/dummies/#usage","title":"Usage","text":"<p>The dummy system provides a simple way of acquiring and recycling dummies. Luckily, dummies are no longer needed for a missile system, but dummies are still very convenient for various other tasks, such as applying in-game (de)buffs to a target (e.g. have it stun a target with a custom zero damage Firebolt spell).</p> <p>Using the dummy system is very straight forward, at any point you can use <code>var dummy = DummySystem.GetDummy(...)</code> to acquire a dummy unit. When you are done with the dummy, you can release it using <code>DummySystem.RecycleDummy(dummy, recycleTime)</code>. The <code>recycleTime</code> argument specifies the time (in seconds) after which the dummy is made available again for use. You may leave it out, in which case it will automatically make the dummy available for use again after 2 seconds.</p>"},{"location":"wcsharp/libraries/effects/","title":"WCSharp.Effects","text":"<p>System is a big word, unlike this \"system\".</p> <p>This system exists due to an unfortunate quirk in Reforged. Many effects do not display properly if you immediately destroy them, as you would before Reforged. In order to address this, you can use <code>EffectSystem.Add(effect, duration)</code> to make the effect automatically be cleaned up after the given duration (in seconds). You may leave out the duration, in which case it defaults to 0.03125 seconds. For the vast majority of effects, they will work fine with the default duration.</p>"},{"location":"wcsharp/libraries/knockbacks/","title":"WCSharp.Knockbacks","text":"<p>The knockback system provides the following features:</p> <ul> <li>Supports any number of knockbacks, potentially multiple on the same unit</li> <li>Customise the distance and duration of knockbacks</li> <li>Via \"reversing the arguments\", can also be used to pull enemies towards a location</li> </ul>"},{"location":"wcsharp/libraries/knockbacks/#usage","title":"Usage","text":"<p>Performing a knockback on a unit is simple, all you need to do is create a new Knockback object using one of the two constructors, which specify either an angle or a position to fly towards, and add it to the system using <code>KnockbackSystem.Add(&lt;knockback&gt;);</code>. Each constructor also allows you to set the distance and duration of the knockback.</p> <p>To calculate the angle of the knockback, you can use the <code>AngleBetweenPoints</code> methods located in <code>WCSharp.Utils</code>.</p>"},{"location":"wcsharp/libraries/knockbacks/#properties","title":"Properties","text":"Name Description Active Inherited from IPeriodicAction. Set to false to disable and remove. Target The target of the knockback. Angle The angle of the knockback in degrees. Speed The distance traversed per tick (0.03125). SpeedDropoff The amount of speed lost per tick (0.03125). Effect1 This effect will be spawned every 1.0 seconds on the target using Effect1AttachmentPoint. Effect2 This effect will be spawned every 0.125 seconds on the target using Effect2AttachmentPoint. Effect1AttachmentPoint The attachment point to use for Effect1. Effect2AttachmentPoint The attachment point to use for Effect2."},{"location":"wcsharp/libraries/lightnings/","title":"WCSharp.Lightings","text":"<p>For basic information on lightning effects, please consult this thread on Hiveworkshop.</p> <p>The lightning system offers the following features:</p> <ul> <li>Customise various properties of each lightning such as the duration, fade behaviour and colour</li> <li>Automatically manages any number of lightning effects</li> <li>Automatically follows moving units, if supplied</li> <li>Supports both lightning effects that last a pre-determined duration, or until cancelled.</li> </ul>"},{"location":"wcsharp/libraries/lightnings/#usage","title":"Usage","text":"<p>The lightning system is similar in use to the Knockback system, in that you simply need to create a new Lightning object, and then add it to the system using <code>LightningSystem.Add(&lt;lightning&gt;)</code>.</p> <p>The lightning system however, features a lot more customisable properties, many of which you'll want to set before adding it to the system. For example, a typical use of the lightning system will look like this:</p> <pre><code>var lightning = new Lightning(\"AFOD\", caster, target)\n{\n    Duration = 1.0f,\n    FadeDuration = 0.5f,\n    CasterHeightOffset = 50f,\n    TargetHeightOffset = 50f,\n};\nLightningSystem.Add(lightning);\n</code></pre> <p>Note that, if Caster/TargetHeightOffset are not specified, the lightning will be directly on the ground, which will often look strange.</p>"},{"location":"wcsharp/libraries/lightnings/#properties","title":"Properties","text":"Name Description Active Inherited from IPeriodicDisposableAction. Set to false to disable and dispose. Caster The caster of the lightning. Setting this means that the lightning will follow the caster when the caster moves. CasterX The X coordinate from which this lightning was fired. While Caster is alive, this will automatically be updated. CasterY The Y coordinate from which this lightning was fired. While Caster is alive, this will automatically be updated. CasterHeightOffset The height that this lightning should originate from. By default, this is the ground. Target The target of the lightning. Setting this means that the lightning will follow the target when the target moves. TargetX The X coordinate that this lightning is targeting. While Target is alive, this will automatically be updated. TargetY The Y coordinate that this lightning is targeting. While Target is alive, this will automatically be updated. TargetHeightOffset The height that this lightning should aim at. By default, this is the ground. Red The red color of this lightning. Setting this to 0 means all red will be removed from the lightning. Green The green color of this lightning. Setting this to 0 means all green will be removed from the lightning. Blue The blue color of this lightning. Setting this to 0 means all blue will be removed from the lightning. Alpha The alpha (transparency) of this lightning. Setting this to 0 means the lightning is invisible. Duration The duration that this lightning should last in total. FadeDuration The length of time over which the lightning will fade."},{"location":"wcsharp/libraries/shared/","title":"WCSharp.Shared","text":"<p>This page needs to be expanded with more exact definitions.</p> <p>A number of convenience methods are defined to make mapmaking easier. Below is a list of the various features:</p> <ul> <li>WorldBounds provides an easy way of accessing the world bounds of a map and various properties of it in an efficient manner.</li> <li>Delay is a small class that can be used to delay a piece of code by a single time step. This can be used to circumvent various issues, such as unit AI locking up if you give them a new order at the same time as they start an attack.</li> <li>Extension methods are provided for various things, such as dealing damage or healing a unit, or iterating a group in an efficient manner.</li> <li>Data classes are provided to simplify working with points and regions (rectangles).</li> <li>Util provides various convenience methods for things such as calculating the distance/angle between points, or handling floating text.</li> </ul>"},{"location":"wcsharp/libraries/shared/#iteratewithremoval","title":"IterateWithRemoval","text":"<p>This method within ListExtensions deserves a special mention, as it implements behaviour to iterate a list and remove items from it as-you-go. In normal C#, this can be easily implemented with a for-loop, but due to quirks of the C# to Lua transpilation process the standard way of doing this breaks. There are various ways around this, the easiest approach being to use a separate list instead, but that eats performance. This extension method instead provides an easy-to-use generic means of iterating any list with in-between removals via a while loop, making it better for performance.</p>"},{"location":"wcsharp/libraries/shared/#lualuatable","title":"Lua/LuaTable","text":"<p>These two classes exist to make it a bit easier for WCSharp to interact with Lua directly. In all likelihood, you want to ignore this. But, if you are a package developer yourself, I can strongly recommend looking into it.</p> <p>Throughout the development of WCSharp, I've had to deal with a lot of issues surrounding executing raw Lua code from a package, and the way I've solved it ended up working incredibly well. In the end it was an incredibly simple approach, but it took me a long time to get there. So by all means, learn from the code there and don't suffer like I did.</p>"},{"location":"wcsharp/libraries/shared/#fastutil","title":"FastUtil","text":"<p>As of v2.1, a <code>FastUtil</code> class is defined alongside <code>Util</code>. However, unless you're desperate for performance, you can just ignore this. The <code>FastUtil</code> methods will inline their calls for maximum performance. However, because of the way this is done, some arguments supplied to its methods should be computed in advance. See IntelliSense to determine which arguments require this. Example:</p> <pre><code>// GOOD\nvar unit = GetTriggerUnit();\nvar angle = AngleBetweenPoints(unit, 0, 0);\n\n// BAD\nvar angle = AngleBetweenPoints(GetTriggerUnit(), 0, 0);\n</code></pre> <p>Additionally, any methods not present in <code>FastUtil</code> are either not able to be inlined, or are already inlined by default (as no argument has the above problem).</p>"},{"location":"wcsharp/libraries/shared/#typewrapper","title":"TypeWrapper","text":"<p>TypeWrapper is a simple wrapper class that can be used to circumvent issues with reflection. This class has no purpose outside of reflection.</p> <p>Normally speaking, if you create a method that expects an argument of type <code>unit</code>, or any other WC3 type, this causes problems with matching that type using reflection, as it may be unable to determine the type of <code>unit</code>. By changing the argument to <code>TypeWrapper&lt;unit&gt;</code>, the issue is resolved.</p>"},{"location":"wcsharp/libraries/sync/","title":"WCSharp.Sync","text":"<p>Use of this package requires that the compilers IsExportMetadata property is set to true.</p> <p>Although probably not directly useful to the average map maker, the sync system is a powerful backbone for WCSharp.SaveLoad and WCSharp.DateTime.</p> <p>The sync system makes it trivial to send generic and complex data structures between players. For example, WCSharp.SaveLoad loads saves from local data, and then has to synchronise this between players. Originally, sync data is limited to strings of 255 characters. Combined with there not being a standard conversion format, this often led to cumbersome custom methods for syncing data.</p> <p>The first giant improvement to this that is made by the sync system is that it uses the WCSharp.JsonConvert package to (de)serialize generic and complex data structures, removing the process of defining custom methods of sending/parsing data for the user. Furthermore, it automatically splits up the data into packets, similar to how the internet works, so that it can send data of any size.</p> <p>The sync system works as a basic subscription model and only has 3 methods:</p> <ul> <li>Subscribe(Action handler) - Subscribes the given handler to receive messages of type T whenever they are received <li>Unsubscribe(Action handler) - Unsubscribes the given handler to receive messages of type T whenever they are received <li>Send(T message) - Initiates a sync process, synchronising the given message to be received by all players. <p>As each subscription is bound to a specific type, it means that different systems can easily subscribe to the different messages without any conflict occurring. Note that the types of the <code>Subscribe/Unsubscribe</code> and <code>Send</code> must match exactly, it does not account for derived/inherited types.</p> <p>As an example use case of the sync system, the below example illustrates how it is used to synchronise timestamps in WCSharp.DateTime:</p> <pre><code>public void Run()\n{\n    // collect current time in seconds...\n\n    // construct message\n    var message = new DateTimeSyncMessage\n    {\n        PlayerId = GetPlayerId(GetLocalPlayer()),\n        Seconds = seconds\n    };\n\n    // subscribe to DateTimeSyncMessage messages and send it\n    SyncSystem.Subscribe&lt;DateTimeSyncMessage&gt;(HandleDateTimeSyncMessage);\n    SyncSystem.Send(message);\n}\n\nprivate void HandleDateTimeSyncMessage(DateTimeSyncMessage message)\n{\n    // handle the received message\n}\n</code></pre>"},{"location":"wcsharp/libraries/w3mmd/","title":"WCSharp.W3MMD","text":"<p>This is a port of W3MMD for C#, a standard for storing game metadata into replay files, which parsers can then utilise in order to display relevant or interesting information about what happened during the game.</p> <p>Other sources of information on W3MMD: - w3gjs - w3gPlus - wc3stats</p> <p>This C# port works largely the same as the vJass and TypeScript versions. Using the <code>W3Mmd</code> class, you can create events, variables, set player flags and emit custom events. You can find a detailed list of its methods at the automatic documentation.</p> <p>Example usage:</p> <pre><code>var killCount = W3Mmd.DefineInt(\"Total kills\", W3MmdGoalType.High, W3MmdSuggestionType.Leaderboard);\nvar killEvent = W3Mmd.DefineEvent(\"Kills\", \"{0} killed {1}\", \"Killer\", \"Victim\");\nPlayerUnitEvents.Register(UnitTypeEvent.Kills, () =&gt;\n{\n    var killer = GetKillingUnit();\n    var victim = GetTriggerUnit();\n    killEvent.Emit(GetUnitName(killer), GetUnitName(victim));\n    killCount.Add(GetOwningPlayer(killer), 1)\n});\n</code></pre>"},{"location":"wcsharp/libraries/buffs/","title":"Buffs","text":"<p>The buff system offers the following features:</p> <ul> <li>Customise various properties of each buff such as duration, effect and tick interval.</li> <li>Automatically manages buffs on any number of targets.</li> <li>Customisable behaviour for stacking of buffs</li> <li>Supports various events such as OnTick or OnExpire.</li> <li>Supports dispelling based on custom buff types.</li> <li>Optionally handles periodic damage/healing ticks.</li> <li>Optionally handles binding to in-game buffs (e.g. for tooltips).</li> </ul>"},{"location":"wcsharp/libraries/buffs/#system","title":"System","text":"<p>The buff system has several features for easily interacting with buffs contained in the system:</p> <ul> <li>When adding buffs to the system, the <code>Add</code> method can be supplied with additional information to handle stacking as desired for that specific buff. For more information, see buff stacking.</li> <li>All buffs that are on a specific unit can be efficiently retrieved using the <code>GetBuffsOnUnit</code> method.</li> <li>The <code>RegisterForOwnershipChanges</code> method can be used to register for events to automatically update <code>CastingPlayer</code> and <code>TargetPlayer</code> when a unit switches ownership.</li> <li>The <code>Dispel</code> method can be used in conjunction with properties on buffs to create complex dispel behaviours. For more information, see buff dispelling.</li> </ul>"},{"location":"wcsharp/libraries/buffs/#type-overview","title":"Type overview","text":"<p>There are 5 base buffs defined that behave differently. These implement some more advanced behaviour, so you can use one of the complexity that meets your requirements. These are as follows:</p> <ul> <li>PassiveBuff: Basic buff with no special features.</li> <li>TickingBuff: This buff adds an interval and event for handling tick behaviour.</li> <li>AutoBuff: In addition to ticks, this buff can also automatically handle damage/healing. This buff corresponds to the buffs in version 1 of the buff system.</li> <li>RollingBuff: This is a specialised buff to manage multiple sub-buffs (stacks), each with their own duration, while only the \"top-level\" buff ticks.</li> <li>BoundBuff: This buff implements special logic to handle connecting it to an in-game buff, which can be applied either via WCSharp.Dummies or via an in-game aura. Besides the binding mechanic, it is functionally identical to the TickingBuff.</li> </ul>"},{"location":"wcsharp/libraries/buffs/#events","title":"Events","text":"Name Description OnApply Executes immediately upon application of the buff. OnDeath Executes immediately after Target dies. OnDispel Executes when an attempt is made to dispel the target. OnDispose Executes when the buff is removed for any reason whatsoever. OnExpire Executes when the buff expires by reaching the end of its duration. Does not trigger when the buff is removed via a dispel or target dies. OnTick Executes every given interval. Present on most, but not all, buffs."},{"location":"wcsharp/libraries/buffs/#properties","title":"Properties","text":"Name Description Active Inherited from IPeriodicDisposableAction. Set to false to disable and dispose. Caster The unit that applied the buff. CastingPlayer The owner of the caster. Automatically set on application. Does NOT automatically update if the caster changes owner. Target The target to which this buff is attached. TargetPlayer The owner of the target. Automatically set on application. Does NOT automatically update if the target changes owner. Duration The remaining duration before this buff expires. IsBeneficial Whether this buff is beneficial or detrimental to the target. BuffTypes The buff types, used primarily for dispelling. e.g. magic, physical, undispellable, etc. Stacks The number of stacks of this buff currently active on the target. Defaults to 1. EffectString The path of the effect to use. Leave empty for no effect. If changed while the buff is already active, will destroy and recreate the effect. EffectAttachmentPoint The attachment point for the effect. If changed while the buff is already active, will destroy and recreate the effect at the desired attachment point. Defaults to origin. EffectScale The effect scale of the missile. If modified mid-flight, automatically modifies the missile. Effect The effect being used by the missile. Creation of the effect should be done by setting , not by setting this property."},{"location":"wcsharp/libraries/buffs/auras/","title":"Auras","text":"<p>The aura system offers the following features:</p> <ul> <li>Automatically manages application and refreshing of buffs in a customisable manner</li> <li>Integrates with the buff system to allow easily customisable buffs to be applied</li> <li>Auras are bound to a specific buff to make it easier to work with</li> </ul>"},{"location":"wcsharp/libraries/buffs/auras/#usage","title":"Usage","text":"<p>Creating an aura requires 2 classes to be created. The first thing we need is the buff to be applied. For this, you should use AuraBoundBuff, which is a small extension of BoundBuff that will help ensure that the auras will stack in a manner similar to default auras. Furthermore, it will ensure that the <code>Stacks</code> property is set to the number of aura bearers applying the buff.</p> <pre><code>using WCSharp.Buffs;\nusing static War3Api.Common;\n\npublic class MyBuff : AuraBoundBuff\n{\n    public MyBuff(unit caster, unit target) : base(caster, target)\n    {\n        EffectString = @\"Abilities\\Spells\\Other\\GeneralAuraTarget\\GeneralAuraTarget.mdl\";\n        Bind(Constants.ABILITY_DEVOTION_AURA, Constants.BUFF_DEVOTION_AURA);\n    }\n\n    public override void OnApply()\n    {\n        BlzSetUnitArmor(Target, BlzGetUnitArmor(Target) + 5);\n    }\n\n    public override void OnExpire()\n    {\n        BlzSetUnitArmor(Target, BlzGetUnitArmor(Target) - 5);\n    }\n}\n</code></pre> <p>We don't need to set a duration here, this will be managed by the aura. For the aura itself, we'll inform C# that the aura should bind to <code>MyBuff</code> by extending it with <code>Aura&lt;MyBuff&gt;</code>. Then we can implement the abstract class, and create something like this:</p> <pre><code>public class MyAura : Aura&lt;MyBuff&gt;\n{\n    public MyAura(unit caster) : base(caster)\n    {\n        Radius = 800;\n        EffectString = @\"Abilities\\Spells\\Human\\DevotionAura\\DevotionAura.mdl\";\n        StackBehaviour = StackBehaviour.Stack;\n    }\n\n    // Use this to create new instances of MyBuff and perform additional initialisation if necessary\n    protected override MyBuff CreateAuraBuff(unit unit)\n    {\n        return new MyBuff(Caster, unit);\n    }\n\n    // Use this to filter on units that should be buffed by this aura\n    protected override bool UnitFilter(unit unit)\n    {\n        return IsUnitAlly(unit, CastingPlayer);\n    }\n}\n</code></pre> <p>And that's it! We now have our own Devotion Aura, including having it show a buff on the unit. This particular implementation won't show a \"+5\" on the unit stats, but you can easily achieve this by increasing the armour via a different method than <code>BlzSetUnitArmor</code>, such as giving the unit an item ability that increases armour.</p> <p>Finally, to add this aura to a unit, simply create a new instance and add it to the system:</p> <pre><code>var unit = GetTriggerUnit();\nvar aura = new MyAura(unit);\nAuraSystem.Add(aura);\n</code></pre>"},{"location":"wcsharp/libraries/buffs/auras/#properties","title":"Properties","text":"Name Description Active Inherited from IPeriodicDisposableAction. Set to false to disable and dispose. Caster The owner of the aura. CastingPlayer The player who owns the aura. This is set on creation, if you want it to automatically update, use <code>AuraSystem.RegisterForOwnershipChanges</code>. Radius The range within which units must be for the aura to be applied to them. Duration The duration in seconds of buffs applied by this aura. Defaults to 3.1. Unless you're making a pulsing aura, you will want the Duration to be greater than the SearchInterval. SearchIntervalLeft How long in seconds until this aura will next be applied to valid units in range. SearchInterval How long in seconds between applications of this aura. Defaults to 1.0. StackBehaviour The stack behaviour of buffs applied by this aura. Note that even with StackBehaviour.None, auras will still only stack once per aura instance. EffectString The path of the effect to use. Leave empty for no effect. If changed while the aura is already active, will destroy and recreate the effect. EffectAttachmentPoint The attachment point for the effect. If changed while the aura is already active, will destroy and recreate the effect at the desired attachment point. Defaults to origin. EffectScale The effect scale for the effect. If changed while the aura is already active, automatically modifies the effect. Effect The effect used by the aura. Creation of the effect should be done by setting EffectString, not by setting this property. ActiveBuffsByUnit A dictionary mapping units to active buffs."},{"location":"wcsharp/libraries/buffs/auto-buff/","title":"AutoBuff","text":"<p>AutoBuff adds the following properties:</p> Name Description IntervalLeft The time, in seconds, remaining until the next tick. Interval The time, in seconds, between each tick. DamagePerInterval The damage to apply on each tick. Set to negative to heal. The damage dealer is the caster if the caster is alive, otherwise the target itself. AttackType The attack type to use when dealing damage. DamageType The damage type to use when dealing damage. <p>These properties are used to invoke the custom <code>OnTick</code> handler every interval, as well as perform the desired amount of damage/healing. Note that <code>OnTick</code> triggers before the automatic damage/healing is performed, so you can adjust the amount per tick in <code>OnTick</code> if desired.</p> <p>If the target dies either from actions performed in <code>OnTick</code> or by the automatic damage/healing step, <code>OnDeath</code> will automatically be called with <code>killingBlow = true</code>.</p> <p>A basic example of an AutoBuff that lasts 10 seconds and ticks each second for increasing amounts (starting at 100):</p> <pre><code>using WCSharp.Buffs;\nusing static War3Api.Common;\n\npublic class MyAutoBuff : AutoBuff\n{\n    public MyAutoBuff(unit caster, unit target) : base(caster, target)\n    {\n        Interval = 1.0f;\n        Duration = 10.0f;\n        EffectString = @\"Abilities\\Spells\\Human\\FlameStrike\\FlameStrikeDamageTarget.mdl\";\n        DamagePerInterval = 90;\n        AttackType = ATTACK_TYPE_CHAOS;\n    }\n\n    public override void OnTick()\n    {\n        DamagePerInterval += 10;\n    }\n}\n</code></pre>"},{"location":"wcsharp/libraries/buffs/bound-buff/","title":"BoundBuff","text":"<p>BoundBuff adds the following properties:</p> Name Description IntervalLeft The time, in seconds, remaining until the next tick. Interval The time, in seconds, between each tick. <p>These properties are used to invoke the custom <code>OnTick</code> handler every interval. If the target dies from actions performed in <code>OnTick</code>, <code>OnDeath</code> will automatically be called with <code>killingBlow = true</code>.</p> <p>Additionally, BoundBuff defines a <code>Bind</code> method that can be used to bind the buff to an in-game buff, so that players can see the tooltip or the flashing when the buff is about to expire. Binding can be performed in two ways.</p> <p>The first binding method is by providing it with an ability that applies a buff which it should cast. The system then retrieves a dummy using WCSharp.Dummies and orders it to cast that ability on the target. For example: <code>Bind(ABILITY_MARK, BUFF_MARK, ORDER_FAERIE_FIRE);</code>. Optional ability level and dummy owner arguments can be supplied to this method. The advantage of this method is that the in-game buff will have a duration, meaning it will flash when it is about to expire. However, dummies can sometimes be uncooperative if cast by CPU players. Of course, another downside is that this method requires dummies, but most of the disadvantages of dummies are negated via WCSharp.Dummies.</p> <p>The second binding method is by providing it with an aura that it should give to the target. The system will then automatically hide the aura and remove both the aura ability and its in-game buff when the buff is removed (meaning there is no aura stickiness). For example: <code>Bind(ABILITY_MARK_AURA, BUFF_MARK);</code>. Optional ability level can be supplied to this method. The advantage of this method is that no dummies are required, and the method is very efficient if the buff can be applied frequently, since the aura just needs to be added once. The downside is that auras do not have a duration, meaning the buff tooltip will not flash when it is about to expire.</p> <p>A basic example of a BoundBuff using the aura binding, that lasts 10 seconds and ticks each second for decreasing amounts (starting at 100):</p> <pre><code>using WCSharp.Buffs;\nusing static War3Api.Common;\n\npublic class Burn : BoundBuff\n{\n    public BoundBuffTest(unit caster, unit target) : base(caster, target)\n    {\n        Interval = 1.0f;\n        Duration = 10.0f;\n        EffectString = @\"Abilities\\Spells\\Human\\FlameStrike\\FlameStrikeDamageTarget.mdl\";\n        Bind(Constants.ABILITY_BURN_AURA, Constants.BUFF_BURN);\n    }\n\n    public override void OnTick()\n    {\n        UnitDamageTarget(Caster, Target, 10 + (Duration * 10), true, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNKNOWN, WEAPON_TYPE_WHOKNOWS);\n    }\n}\n</code></pre>"},{"location":"wcsharp/libraries/buffs/buff-dispelling/","title":"Buff Dispelling","text":"<p>The buff system can handle dispelling of buffs on a target with matching on the <code>IsBeneficial</code> and <code>BuffTypes</code> properties. Buff types is a list of strings, allowing you to define buffs with multiple types that will be matched on via the various different <code>BuffSystem.Dispel</code> options. Additionally, the <code>OnDispel</code> handler can be used to create more complex dispel interactions, such as dispel resistance or special actions. All dispelled buffs are also returned, allowing for the dispel to interact with the results as well. To showcase the possibilities, a number of examples are outlined below.</p> <p>For a buff to be fully dispelled, it should set its <code>Stacks</code> property to 0, and then the system will automatically dispose the buff afterwards. For reference, below is the base implementation of <code>OnDispel</code>:</p> <pre><code>public int OnDispel(unit dispeller, int dispelCharges)\n{\n    // determine how many stacks can be dispelled\n    var stacksToDispel = Math.Min(Stacks, dispelCharges);\n    // reduce stacks\n    Stacks -= stacksToDispel;\n    // return number of dispel charges used\n    return stacksToDispel;\n}\n</code></pre> <p>The below example will dispel up to 3 buffs, and heal the dispelled unit for 100 for each dispelled buff stack:</p> <pre><code>var life = GetUnitState(target, UNIT_STATE_LIFE);\nforeach (var dispel in BuffSystem.Dispel(target, caster, false, 3, \"Magic\"))\n{\n    life += dispel.BuffStacksDispelled * 100;\n}\nSetUnitState(target, UNIT_STATE_LIFE, life);\n</code></pre> <p>The below buff has a 25% chance to resist dispels:</p> <pre><code>public override int OnDispel(unit dispeller, int dispelCharges)\n{\n    for (var i = 0; i &lt; dispelCharges; i++)\n    {\n        if (GetRandomInt(1, 4) != 1)\n        {\n            Stacks--;\n\n            if (Stacks == 0)\n            {\n                // no stacks left, return number of loops that were needed\n                return i;\n            }\n        }\n    }\n\n    // All dispel charges were consumed\n    return dispelCharges;\n}\n</code></pre> <p>The below buff will deal 1000 damage to the target when it is dispelled:</p> <pre><code>public override int OnDispel(unit dispeller, int dispelCharges)\n{\n    UnitDamageTarget(Caster, Target, 1000, true, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNKNOWN, WEAPON_TYPE_WHOKNOWS);\n\n    // Base method is fine for updating stacks/calculating dispel charges consumed\n    return base.OnDispel();\n}\n</code></pre>"},{"location":"wcsharp/libraries/buffs/buff-stacking/","title":"Buff Stacking","text":"<p>The buff system can be supplied with additional parameters so that it can handle stacking buffs as desired, including things such as a stack counter and per-unit or per-player level stacking.</p> <p>This is achieved by supplying the <code>Add</code> method with a <code>StackBehaviour</code>. The following stack behaviours are defined:</p> Name Description None Will not stack in any way Stack Will stack with all instances of itself StackCaster Will stack with all instances of itself cast by the same unit StackPlayer Will stack with all instances of itself cast by the same player <p>If the stack behaviour is anything except <code>None</code>, what will happen is that it will iterate over all buffs already on the target, and find buffs with the same type as the one being applied. When it finds one, it invokes the <code>OnStack</code> method of the buff currently applied to the target. The <code>OnStack</code> method can then be used to further customise what should happen on a stack attempt. For example, this is the default implementation:</p> <pre><code>public override StackResult OnStack(Buff newStack)\n{\n    Stacks += newStack.Stacks;\n    Duration = Math.Max(Duration, newStack.Duration);\n    return StackResult.Stack;\n}\n</code></pre> <p>This simply increases the <code>Stacks</code> property by the number of stacks on the new buff, refreshes the duration, and confirms that the buffs were stacked, at which point the new buff is discarded. The following stack results are defined:</p> Name Description Reject The stack attempt is rejected, and the buffs will be applied separately Stack The stack attempt is successful, and the new buff is discarded Consume The stack attempt is successful, and the old buff is discarded (will be automatically disposed) <p>Using these components, any stack behaviour can be achieved, some examples can be found below.</p> <p>The following will create a separate stack of the buff for each unit, with a maximum of 5 stacks:</p> <pre><code>BuffSystem.Add(buff, StackBehaviour.StackCaster)\n...\npublic override StackResult OnStack(Buff newStack)\n{\n    Stacks = Math.Min(5, Stacks + newStack.Stacks);\n    Duration = Math.Max(Duration, newStack.Duration);\n    return StackResult.Stack;\n}\n</code></pre> <p>The following will damage the target for 10 times the duration left on the previous buff, then apply the new buff:</p> <pre><code>BuffSystem.Add(buff, StackBehaviour.Stack)\n...\npublic override StackResult OnStack(Buff newStack)\n{\n    UnitDamageTarget(Caster, Target, Duration * 10, true, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNKNOWN, WEAPON_TYPE_WHOKNOWS);\n    return StackResult.Consume;\n}\n</code></pre> <p>The following create a separate stack of the buff for each player and deal 1000 damage to the target upon reaching 10 stacks. It then disposes (removes) itself.</p> <pre><code>BuffSystem.Add(buff, StackBehaviour.StackPlayer)\n...\npublic override StackResult OnStack(Buff newStack)\n{\n    Stacks = Math.Min(10, Stacks + newStack.Stacks);\n    Duration = Math.Max(Duration, newStack.Duration);\n    if (Stacks == 10)\n    {\n        UnitDamageTarget(Caster, Target, 1000, true, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNKNOWN, WEAPON_TYPE_WHOKNOWS);\n        Dispose();\n    }\n    return StackResult.Stack;\n}\n</code></pre>"},{"location":"wcsharp/libraries/buffs/passive-buff/","title":"PassiveBuff","text":"<p>PassiveBuff is the simplest buff. It is intended as a simple apply-expire buff that does nothing over its duration, and as such comes with no added baggage.</p> <p>The below example is a simple aura that increases the targets armour by 5 when applied, and decreases it by 5 when it is disposed.</p> <pre><code>using WCSharp.Buffs;\nusing static War3Api.Common;\n\npublic class MyPassiveBuff : PassiveBuff\n{\n    public MyBuff(unit caster, unit target) : base(caster, target)\n    {\n        Duration = 10.0f;\n        EffectString = @\"Abilities\\Spells\\Human\\DevotionAura\\DevotionAura.mdl\";\n    }\n\n    public override void OnApply()\n    {\n        BlzSetUnitArmor(Target, BlzGetUnitArmor(Target) + 5);\n    }\n\n    public override void OnDispose()\n    {\n        if (UnitAlive(Target))\n        {\n            BlzSetUnitArmor(Target, BlzGetUnitArmor(Target) - 5);       \n        }\n    }\n}\n</code></pre>"},{"location":"wcsharp/libraries/buffs/rolling-buff/","title":"RollingBuff","text":"<p>RollingBuff adds the following properties:</p> Name Description IntervalLeft The time, in seconds, remaining until the next tick. Interval The time, in seconds, between each tick. IsMainStack Whether the current instance is the main stack (i.e. the instance that manages underlying instances). Buffs All buffs underlying the main buff instance. <p>These properties are used to invoke the custom <code>OnTick</code> handler every interval. If the target dies from actions performed in <code>OnTick</code>, <code>OnDeath</code> will automatically be called with <code>killingBlow = true</code>.</p> <p>RollingBuff is a specialised buff that will manage multiple underlying buffs, but behave as a single buff. Every time a buff is added via a call to <code>OnStack</code>, it increases the <code>Stack</code> property, adds the buff to a list, and manages their duration and expiration individually (the stacked buff is not added to the buff system). When one of the underlying stacks expire, the <code>OnExpireStack</code> handler is called and <code>Stacks</code> is decreased.</p> <p>The <code>OnTick</code> method for RollingBuff is only called for the main buff, not the underlying buffs. The <code>OnStack</code> method should always invoke <code>base.OnStack(newStack)</code> when you override it.</p> <p>A basic example of a TickingBuff that lasts 10 seconds and ticks each second 10 times the number of stacks applied to the target:</p> <pre><code>using WCSharp.Buffs;\nusing static War3Api.Common;\n\npublic class MyRollingBuff : RollingBuff&lt;MyRollingBuff&gt;\n{\n    public MyRollingBuff(unit caster, unit target) : base(caster, target)\n    {\n        Interval = 1.0f;\n        Duration = 10.0f;\n        EffectString = @\"Abilities\\Spells\\Human\\FlameStrike\\FlameStrikeDamageTarget.mdl\";\n    }\n\n    public override void OnTick()\n    {\n        UnitDamageTarget(Caster, Target, Stacks * 10, true, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNKNOWN, WEAPON_TYPE_WHOKNOWS);\n    }\n}\n</code></pre> <p>This behaviour is subtly different from other approaches, for example using multiple non-stacking <code>TickingBuff</code> will deal damage multiple times instead of once. Alternatively, using a single stacking <code>TickingBuff</code> will deal damage once, but loses the individual durations of each stack.</p> <p>Finally, although RollingBuff does not currently have built-in support for connecting it to an in-game buff, it is not difficult to implement this yourself by giving the target an aura in the <code>OnApply</code>, and removing it in the <code>OnDispose</code>.</p>"},{"location":"wcsharp/libraries/buffs/ticking-buff/","title":"TickingBuff","text":"<p>TickingBuff adds the following properties:</p> Name Description IntervalLeft The time, in seconds, remaining until the next tick. Interval The time, in seconds, between each tick. <p>These properties are used to invoke the custom <code>OnTick</code> handler every interval. If the target dies from actions performed in <code>OnTick</code>, <code>OnDeath</code> will automatically be called with <code>killingBlow = true</code>.</p> <p>A basic example of a TickingBuff that lasts 10 seconds and ticks each second for decreasing amounts (starting at 100):</p> <pre><code>using WCSharp.Buffs;\nusing static War3Api.Common;\n\npublic class MyTickingBuff : TickingBuff\n{\n    public MyTickingBuff(unit caster, unit target) : base(caster, target)\n    {\n        Interval = 1.0f;\n        Duration = 10.0f;\n        EffectString = @\"Abilities\\Spells\\Human\\FlameStrike\\FlameStrikeDamageTarget.mdl\";\n    }\n\n    public override void OnTick()\n    {\n        UnitDamageTarget(Caster, Target, 10 + (Duration * 10), true, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNKNOWN, WEAPON_TYPE_WHOKNOWS);\n    }\n}\n</code></pre> <p>Note that AutoBuff will often be easier if you're only interested in performing damage or healing on the target.</p>"},{"location":"wcsharp/libraries/events/","title":"WCSharp.Events","text":"<p>WCSharp.Events is a set of systems designed to simplify and improve working with events in Warcraft III by having them handle the creation of triggers for you. Additionally, these systems are aimed for high performance and will bundle together events where possible.</p> <p>Currently, there are two systems defined:</p> <ul> <li>PeriodicEvents - This system allows for the easy addition of periodic events and triggers in a natural way, allowing you to create any number of concurrent instances for actions.</li> <li>PlayerUnitEvents - This system is designed as a complete replacement of Warcraft III's playerunitevent types. Events using the same underlying Warcraft III event are bundled together, and it allows for constant time filtering on any given event value.</li> </ul>"},{"location":"wcsharp/libraries/events/periodic-events/","title":"PeriodicEvents","text":"<p>The periodic events system offers the following features:</p> <ul> <li>Manages all periodic events on the same timer, while ensuring that each event fires at its appropriate time, and are removed when no longer in use.</li> <li>Offers a PeriodicTrigger class to easily create and automatically manage multi-instanceable events.</li> </ul>"},{"location":"wcsharp/libraries/events/periodic-events/#usage","title":"Usage","text":"<p>There are two ways to use the periodic events system. The first is using <code>PeriodicEvents.AddPeriodicEvent(func, period)</code>. This will create a PeriodicEvent handler that will continue to loop until the <code>func</code> returns false. This is mainly intended to be used when a single instance can handle everything, such as e.g. resource ticks in a map.</p> <p>In most cases, you will want to use a PeriodicTrigger instead. This class allows you to easily create and add multiple instances of a trigger. Due to its design, it is automatically a multi-instanceable event, as each instance is independently managed by the PeriodicTrigger.</p> <p>To begin using a PeriodicTrigger, we first need to create a new class that implements IPeriodicAction:</p> <pre><code>public class TestTrigger : IPeriodicAction\n{\n}\n</code></pre> <p>To implement this interface, simply press ALT+Enter while you have the name of the class selected and choose to implement the interface, which will produce the following: <pre><code>public class TestTrigger : IPeriodicAction\n{\n    public bool Active { get; set; }\n\n    public void Action()\n    {\n\n    }\n}\n</code></pre></p> <p>From here, we can fill in <code>Action</code> with whatever tasks should be done on every tick of this periodic action . When we no longer want the periodic action to continue, simply set <code>Active</code> to false.</p> <p>Now we just need to actually create our PeriodicTrigger to manage this periodic action. For example, the below code will, for each unit created, attach a periodic action that causes the unit to deal 10 Chaos damage to itself every second for as long as it lives.</p> <pre><code>public class TestTrigger : IPeriodicAction\n{\n    public static PeriodicTrigger&lt;TestTrigger&gt; periodicTrigger;\n\n    public static void Initialize()\n    {\n        periodicTrigger = new PeriodicTrigger&lt;TestTrigger&gt;(1.0f);\n        PlayerUnitEvents.Register(PlayerUnitEvent.UnitIsCreated, OnUnitCreated)\n    }\n\n    private static void OnUnitCreated()\n    {\n        periodicTrigger.Add(new TestTrigger\n        {\n            Target = GetTriggerUnit()\n        });\n    }\n\n    public bool Active { get; set; }\n    public unit Target { get; set; }\n\n    public void Action()\n    {\n        if (UnitAlive(Target))\n        {\n            Target.Damage(Target, 10.0f, ATTACK_TYPE_CHAOS);\n        }\n        else\n        {\n            Active = false;\n        }\n    }\n}\n</code></pre>"},{"location":"wcsharp/libraries/events/periodic-events/#periodicdisposabletrigger","title":"PeriodicDisposableTrigger","text":"<p>An alternative to <code>IPeriodicAction/PeriodicTrigger</code> is <code>IPeriodicDisposableAction/PeriodicDisposableTrigger</code>. These two essentially work the same, but add an additional <code>Dispose</code> method to every IPeriodicDisposableAction that is automatically invoked after <code>Active</code> is set to false. This alternative is used by, for example, WCSharp.Missiles to clean up the special effect and perform other required actions.</p>"},{"location":"wcsharp/libraries/events/periodic-events/#smoothtrigger-smoothdisposabletrigger","title":"SmoothTrigger / SmoothDisposableTrigger","text":"<p>Additionally, there are \"smooth\" variants of the standard periodic ones. These are for when you want the actions to trigger more granularly from one another.</p> <p>For example, consider if you have a PeriodicTrigger with an interval of 1 seconds. At time 0.0, you add Action1, at time 0.5, you add Action2. In this case, both actions will execute at time 1.0, 2.0, 3.0, etc. This is generally not a significant issue if your interval is small, players won't notice anyway. However, if your interval is longer, it can become more noticeable and even problematic.</p> <p>For this reason, SmoothTrigger and SmoothDisposableTrigger offer a smoother alternative. In the above example, they will maintain the initial add timings, and trigger Action1 at 1.0/2.0/3.0 and Action2 at 0.5/1.5/2.5.</p>"},{"location":"wcsharp/libraries/events/player-unit-events-v2.0/","title":"PlayerUnitEvents v2.0","text":"<p>Warning</p> <p>This version of WCSharp.Events has been deprecated. For the v2.1+ version, see PlayerUnitEvents v2.1.</p>"},{"location":"wcsharp/libraries/events/player-unit-events-v2.0/#description","title":"Description","text":"<p>The PlayerUnitEvents system is a powerful system to replace the native <code>playerunitevent</code> events, with a focus on improving performance. It offers the following features:</p> <ul> <li>Automates creation of triggers and registration of events used. The user only needs to attach actions to events.</li> <li>Easily attach any number of listeners to events.</li> <li>Filter events with a dictionary on some function. For example, you can supply an integer to use with <code>UnitPlayerEvent.UnitTypeKills</code>, so that the code only triggers when that unit type kills something. Multiple event registrations to this will use a dictionary, so you can listen for dozens of different unit types on the same event without any change in performance.</li> <li>Automatically merges events that use the same native event for performance gains. One of the most expensive steps for events is transitioning from internal WarCraft 3 code into the actual user triggers, and this is avoided by only using a single event.</li> <li>Using some preprocessing steps, will only run what is actually in use.</li> <li>Provides numerous new events for ease of use. These events still rely on the natives behind the scenes, therefore not incurring additional performance costs. They only exist to simplify the logic.</li> <li>Do you want to filter events by something not provided by default? No problem! You can register your own custom event filters. Their performance is exactly the same as events that are provided by default.</li> </ul>"},{"location":"wcsharp/libraries/events/player-unit-events-v2.0/#usage","title":"Usage","text":"<p>This system is used by registering/unregistering events and actions. This is done with the following methods:</p> <ul> <li><code>PlayerUnitEvents.Register(PlayerUnitEvent, action)</code> - Will invoke the given action when the given event fires.</li> <li><code>PlayerUnitEvents.Register(PlayerUnitEvent, action, filterTypeId)</code> - Will invoke the given action when the given event fires, filtered by the type id supplied. Explanations for what the type means in correlation to each event is typically intuitive to the name of the event, and further explanations are supplied by IntelliSense in Visual Studio.</li> <li><code>PlayerUnitEvents.Register(identifier, action, filterTypeId)</code> - The same as above, but the identifier refers to a custom event that was added using <code>AddCustomEventFilter</code>.</li> <li><code>PlayerUnitEvents.Unregister(PlayerUnitEvent, action)</code> - Removes a previously registered action for the given event if possible.</li> <li><code>PlayerUnitEvents.Unregister(PlayerUnitEvent, filterTypeId)</code> - Removes a previously registered action for the given event/type filter if possible.</li> <li><code>PlayerUnitEvents.Unregister(identifier, filterTypeId)</code> - The same as above, but the identifier refers to a custom event that was added using <code>AddCustomEventFilter</code>.</li> </ul> <p>For those unfamiliar with C#, Actions can be either a method or a lambda function such as <code>() =&gt; { ... do some actions ... }</code>.</p> <p>Custom events are created using <code>PlayerUnitEvents.AddCustomEventFilter</code>. For example, the custom event equivalent of <code>PlayerUnitEvent.UnitTypeKills</code> would be: <code>AddCustomEventFilter(EVENT_PLAYER_UNIT_DEATH, \"SomeIdentifier\", () =&gt; GetUnitTypeId(GetKillingUnit()))</code>. You can then use \"SomeIdentifier\" to register any number of events to this custom event. Absolute worth it if you want to register multiple events to the same type of filer! There is no performance difference between an event predefined in <code>PlayerUnitEvent</code> and one that is custom defined.</p> <p>IMPORTANT: Due to quirks of the C# to Lua conversion, you cannot refer directly to WC3 natives when adding custom event filters. They must be enclosed in either a method or a lambda.</p> <p>These WILL work:</p> <pre><code>PlayerUnitEvents.AddCustomEventFilter(EVENT_PLAYER_UNIT_TRAIN_START, \"UnitTypeStartsBeingTrained\", () =&gt; GetTrainedUnitType());\nPlayerUnitEvents.AddCustomEventFilter(EVENT_PLAYER_UNIT_TRAIN_START, \"UnitTypeStartsBeingTrained\", MyFilterMethod);\n\nstatic int MyFilterMethod()\n{\n    return GetTrainedUnitType();\n}\n</code></pre> <p>This WILL NOT work:</p> <pre><code>PlayerUnitEvents.AddCustomEventFilter(EVENT_PLAYER_UNIT_TRAIN_START, \"UnitTypeStartsBeingTrained\", GetTrainedUnitType);\n</code></pre>"},{"location":"wcsharp/libraries/events/player-unit-events-v2.0/#events","title":"Events","text":"<p>The following events are currently supported by default:</p> <ul> <li>HeroTypeBecomesRevivable</li> <li>HeroTypeCancelsRevive</li> <li>HeroTypeFinishesRevive</li> <li>HeroTypeLearnsSpell</li> <li>HeroTypeLevels</li> <li>HeroTypeStartsRevive</li> <li>ItemTypeIsDropped</li> <li>ItemTypeIsPawned</li> <li>ItemTypeIsPickedUp</li> <li>ItemTypeIsSold</li> <li>ItemTypeIsStacked</li> <li>ItemTypeIsUsed</li> <li>PlayerDeselectsUnitType</li> <li>PlayerSelectsUnitType</li> <li>ResearchIsCancelled</li> <li>ResearchIsFinished</li> <li>ResearchIsStarted</li> <li>SpellCast</li> <li>SpellCastOnUnitType</li> <li>SpellChannel</li> <li>SpellChannelOnUnitType</li> <li>SpellEffect</li> <li>SpellEffectOnUnitType</li> <li>SpellEndCast</li> <li>SpellEndCastOnUnitType</li> <li>SpellFinish</li> <li>SpellFinishOnUnitType</li> <li>SpellLearnedByHeroType</li> <li>UnitTypeAttacks</li> <li>UnitTypeCancelsBeingConstructed</li> <li>UnitTypeCancelsBeingTrained</li> <li>UnitTypeCancelsConstruction</li> <li>UnitTypeCancelsResearch</li> <li>UnitTypeCancelsTraining</li> <li>UnitTypeCancelsUpgrade</li> <li>UnitTypeChangesOwner</li> <li>UnitTypeDamages</li> <li>UnitTypeDecays</li> <li>UnitTypeDies</li> <li>UnitTypeDropsItem</li> <li>UnitTypeFinishesBeingConstructed</li> <li>UnitTypeFinishesBeingTrained</li> <li>UnitTypeFinishesConstruction</li> <li>UnitTypeFinishesResearch</li> <li>UnitTypeFinishesTraining</li> <li>UnitTypeFinishesUpgrade</li> <li>UnitTypeIsAttacked</li> <li>UnitTypeIsCreated</li> <li>UnitTypeIsDamaged</li> <li>UnitTypeIsDeselected</li> <li>UnitTypeIsDetected</li> <li>UnitTypeIsHidden</li> <li>UnitTypeIsLoaded</li> <li>UnitTypeIsRescued</li> <li>UnitTypeIsSelected</li> <li>UnitTypeIsSold</li> <li>UnitTypeIsSummoned</li> <li>UnitTypeKills</li> <li>UnitTypeLoads</li> <li>UnitTypePawnsItem</li> <li>UnitTypePicksUpItem</li> <li>UnitTypeReceivesOrder</li> <li>UnitTypeReceivesPointOrder</li> <li>UnitTypeReceivesTargetOrder</li> <li>UnitTypeReceivesUnitTypeOrder</li> <li>UnitTypeRescues</li> <li>UnitTypeSellsItem</li> <li>UnitTypeSellsUnitType</li> <li>UnitTypeSpellCast</li> <li>UnitTypeSpellChannel</li> <li>UnitTypeSpellEffect</li> <li>UnitTypeSpellEndCast</li> <li>UnitTypeSpellFinish</li> <li>UnitTypeStacksItem</li> <li>UnitTypeStartsBeingConstructed</li> <li>UnitTypeStartsBeingTrained</li> <li>UnitTypeStartsConstruction</li> <li>UnitTypeStartsResearch</li> <li>UnitTypeStartsTraining</li> <li>UnitTypeStartsUpgrade</li> <li>UnitTypeSummons</li> <li>UnitTypeUsesItem</li> </ul>"},{"location":"wcsharp/libraries/events/player-unit-events/","title":"PlayerUnitEvents","text":"<p>The PlayerUnitEvents system is a powerful system to replace the native <code>playerunitevent</code> events, with a focus on improving performance. It offers the following features:</p> <ul> <li>Automates creation of triggers and registration of events used. The user only needs to attach actions to events.</li> <li>Easily attach any number of listeners to events.</li> <li>Filter events with a dictionary on some function. For example, you can supply an integer to use with <code>UnitTypeEvent.Kills</code>, so that the code only triggers when that unit type kills something. Multiple event registrations to this will use a dictionary, so you can listen for dozens of different unit types on the same event without any change in performance.</li> <li>Automatically merges events that use the same native event for performance gains. One of the most expensive steps for events is transitioning from internal WarCraft 3 code into the actual user triggers, and this is avoided by only using a single event.</li> <li>Using some preprocessing steps, will only run what is actually in use.</li> <li>Provides numerous new events for ease of use. These events still rely on the natives behind the scenes, therefore not incurring additional performance costs. They only exist to simplify the logic.</li> <li>Do you want to filter events by something not provided by default? No problem! You can register your own custom event filters. Their performance is exactly the same as events that are provided by default.</li> </ul>"},{"location":"wcsharp/libraries/events/player-unit-events/#improvements-over-v20","title":"Improvements over v2.0","text":"<p>WCSharp.Events v2.1 improves the following aspects of v2.0:</p> <ul> <li>Makes events clearer and more concise. For example, what used to be <code>PlayerUnitEvent.UnitTypeKills</code> is now <code>UnitTypeEvent.Kills</code>. This new style also allows more distinct events based on the same underlying event, such as <code>ItemTypeEvent.IsPickedUp</code> and <code>UnitTypeEvent.PicksUpItem</code>.</li> <li>By having different event types (such as UnitTypeEvent, ItemTypeEvent, SpellEvent, etc), IntelliSense can provide more information on expected parameters.</li> <li>Directly supports single-source events, i.e. specific units instead of entire unit types.</li> <li>Addresses problems with registering to the same event with the same filter multiple times. WCSharp will now merge these events for you, instead of forcing you to do so.</li> </ul>"},{"location":"wcsharp/libraries/events/player-unit-events/#usage","title":"Usage","text":"<p>This system is used by registering/unregistering events and actions. This is done with the following methods:</p> <ul> <li><code>PlayerUnitEvents.Register(eventType, action)</code> - Will invoke the given action when the given event fires.</li> <li><code>PlayerUnitEvents.Register(eventType, action, filterTypeId)</code> - Will invoke the given action when the given event fires, filtered by the type id supplied. Explanations for what the type means in correlation to each event is typically intuitive to the name of the event, and further explanations are supplied by IntelliSense in Visual Studio.</li> <li><code>PlayerUnitEvents.Unregister(eventType, action)</code> - Removes a previously registered action for the given event if possible.</li> <li><code>PlayerUnitEvents.Unregister(eventType, filterTypeId)</code> - Removes a previously registered action for the given event/type filter if possible.</li> </ul> <p>For those unfamiliar with C#, Actions can be either a method or a lambda function such as <code>() =&gt; { ... do some actions ... }</code>. Additionally, <code>eventType</code> refers to one of the event types. A full list is supplied below.</p>"},{"location":"wcsharp/libraries/events/player-unit-events/#events","title":"Events","text":"<p>Hero events are triggered by a specific hero. <code>filterTypeId</code> is a unit object and must be supplied.</p> <ul> <li>HeroEvent.BecomesRevivable</li> <li>HeroEvent.CancelsRevive</li> <li>HeroEvent.FinishesRevive</li> <li>HeroEvent.LearnsSpell</li> <li>HeroEvent.Levels</li> <li>HeroEvent.StartsRevive</li> </ul> <p>Hero type events are triggered by any hero of the given unit type. <code>filterTypeId</code> is a unit type id (integer). By not specifying a unit type, it will trigger for any hero regardless of unit type.</p> <ul> <li>HeroTypeEvent.BecomesRevivable</li> <li>HeroTypeEvent.CancelsRevive</li> <li>HeroTypeEvent.FinishesRevive</li> <li>HeroTypeEvent.LearnsSpell</li> <li>HeroTypeEvent.Levels</li> <li>HeroTypeEvent.StartsRevive</li> </ul> <p>Item events are triggered by specific items. <code>filterTypeId</code> is an item object and must be supplied.</p> <ul> <li>ItemEvent.IsAbsorbed</li> <li>ItemEvent.IsDropped</li> <li>ItemEvent.IsPawned</li> <li>ItemEvent.IsPickedUp</li> <li>ItemEvent.IsSold</li> <li>ItemEvent.IsStacked</li> <li>ItemEvent.IsUsed</li> </ul> <p>Item type events are triggered by any item of the given item type. <code>filterTypeId</code> is a item type id (integer). By not specifying an item type, it will trigger for any item regardless of item type.</p> <ul> <li>ItemTypeEvent.IsAbsorbed</li> <li>ItemTypeEvent.IsDropped</li> <li>ItemTypeEvent.IsPawned</li> <li>ItemTypeEvent.IsPickedUp</li> <li>ItemTypeEvent.IsSold</li> <li>ItemTypeEvent.IsStacked</li> <li>ItemTypeEvent.IsUsed</li> </ul> <p>Player events are triggered by the actions of a specific player. <code>filterTypeId</code> can be given either a 0-indexed player id or a player object. By not specifying either, it will trigger for any player.</p> <ul> <li>PlayerEvent.DeselectsUnit</li> <li>PlayerEvent.GainsOwnership</li> <li>PlayerEvent.LosesOwnership</li> <li>PlayerEvent.SelectsUnit</li> </ul> <p>Research events are triggered by a specific research. <code>filterTypeId</code> is the object editor identifier of the research. By not specifying an identifier, it will trigger for any research.</p> <ul> <li>ResearchEvent.IsCancelled</li> <li>ResearchEvent.IsFinished</li> <li>ResearchEvent.IsStarted</li> </ul> <p>Spell events are triggered by abilities of the given ability type. <code>filterTypeId</code> is the object editor identifier of the ability. By not specifying an ability type, it will trigger for any ability.</p> <ul> <li>SpellEvent.Cast</li> <li>SpellEvent.Channel</li> <li>SpellEvent.Effect</li> <li>SpellEvent.EndCast</li> <li>SpellEvent.Finish</li> <li>SpellEvent.Learned</li> </ul> <p>Unit events are triggered by specific unit, hero or building. <code>filterTypeId</code> is a unit object and must be supplied.</p> <ul> <li>UnitEvent.Attacks</li> <li>UnitEvent.BuysUnit</li> <li>UnitEvent.CancelsBeingConstructed</li> <li>UnitEvent.CancelsConstruction</li> <li>UnitEvent.CancelsResearch</li> <li>UnitEvent.CancelsTraining</li> <li>UnitEvent.CancelsUpgrade</li> <li>UnitEvent.ChangesOwner</li> <li>UnitEvent.Damaging</li> <li>UnitEvent.Decays</li> <li>UnitEvent.Dies</li> <li>UnitEvent.DropsItem</li> <li>UnitEvent.FinishesBeingConstructed</li> <li>UnitEvent.FinishesConstruction</li> <li>UnitEvent.FinishesResearch</li> <li>UnitEvent.FinishesTraining</li> <li>UnitEvent.FinishesUpgrade</li> <li>UnitEvent.IsAttacked</li> <li>UnitEvent.IsDamaged</li> <li>UnitEvent.IsDeselected</li> <li>UnitEvent.IsDetected</li> <li>UnitEvent.IsHidden</li> <li>UnitEvent.IsLoaded</li> <li>UnitEvent.IsRescued</li> <li>UnitEvent.IsSelected</li> <li>UnitEvent.IsSold</li> <li>UnitEvent.Kills</li> <li>UnitEvent.Loads</li> <li>UnitEvent.PawnsItem</li> <li>UnitEvent.PicksUpItem</li> <li>UnitEvent.ReceivesOrder</li> <li>UnitEvent.ReceivesPointOrder</li> <li>UnitEvent.ReceivesTargetOrder</li> <li>UnitEvent.ReceivesUnitTypeOrder</li> <li>UnitEvent.Rescues</li> <li>UnitEvent.SellsItem</li> <li>UnitEvent.SellsUnit</li> <li>UnitEvent.SpellCast</li> <li>UnitEvent.SpellCastOn</li> <li>UnitEvent.SpellChannel</li> <li>UnitEvent.SpellChannelOn</li> <li>UnitEvent.SpellEffect</li> <li>UnitEvent.SpellEffectOn</li> <li>UnitEvent.SpellEndCast</li> <li>UnitEvent.SpellEndCastOn</li> <li>UnitEvent.SpellFinish</li> <li>UnitEvent.SpellFinishOn</li> <li>UnitEvent.StacksItem</li> <li>UnitEvent.StartsConstruction</li> <li>UnitEvent.StartsResearch</li> <li>UnitEvent.StartsTraining</li> <li>UnitEvent.StartsUpgrade</li> <li>UnitEvent.Summons</li> <li>UnitEvent.UsesItem</li> </ul> <p>Unit type events are triggered by units of the given unit type. <code>filterTypeId</code> is a unit type id (integer). By not specifying a unit type, it will trigger for any unit, regardless of unit type.</p> <ul> <li>UnitTypeEvent.Attacks</li> <li>UnitTypeEvent.BuysUnit</li> <li>UnitTypeEvent.CancelsBeingConstructed</li> <li>UnitTypeEvent.CancelsBeingTrained</li> <li>UnitTypeEvent.CancelsConstruction</li> <li>UnitTypeEvent.CancelsResearch</li> <li>UnitTypeEvent.CancelsTraining</li> <li>UnitTypeEvent.CancelsUpgrade</li> <li>UnitTypeEvent.ChangesOwner</li> <li>UnitTypeEvent.Damaging</li> <li>UnitTypeEvent.Decays</li> <li>UnitTypeEvent.Dies</li> <li>UnitTypeEvent.DropsItem</li> <li>UnitTypeEvent.FinishesBeingConstructed</li> <li>UnitTypeEvent.FinishesBeingTrained</li> <li>UnitTypeEvent.FinishesConstruction</li> <li>UnitTypeEvent.FinishesResearch</li> <li>UnitTypeEvent.FinishesTraining</li> <li>UnitTypeEvent.FinishesUpgrade</li> <li>UnitTypeEvent.IsAttacked</li> <li>UnitTypeEvent.IsCreated</li> <li>UnitTypeEvent.IsDamaged</li> <li>UnitTypeEvent.IsDeselected</li> <li>UnitTypeEvent.IsDetected</li> <li>UnitTypeEvent.IsHidden</li> <li>UnitTypeEvent.IsLoaded</li> <li>UnitTypeEvent.IsRescued</li> <li>UnitTypeEvent.IsSelected</li> <li>UnitTypeEvent.IsSold</li> <li>UnitTypeEvent.IsSummoned</li> <li>UnitTypeEvent.Kills</li> <li>UnitTypeEvent.Loads</li> <li>UnitTypeEvent.PawnsItem</li> <li>UnitTypeEvent.PicksUpItem</li> <li>UnitTypeEvent.ReceivesOrder</li> <li>UnitTypeEvent.ReceivesPointOrder</li> <li>UnitTypeEvent.ReceivesTargetOrder</li> <li>UnitTypeEvent.ReceivesUnitTypeOrder</li> <li>UnitTypeEvent.Rescues</li> <li>UnitTypeEvent.SellsItem</li> <li>UnitTypeEvent.SellsUnit</li> <li>UnitTypeEvent.SpellCast</li> <li>UnitTypeEvent.SpellCastOn</li> <li>UnitTypeEvent.SpellChannel</li> <li>UnitTypeEvent.SpellChannelOn</li> <li>UnitTypeEvent.SpellEffect</li> <li>UnitTypeEvent.SpellEffectOn</li> <li>UnitTypeEvent.SpellEndCast</li> <li>UnitTypeEvent.SpellEndCastOn</li> <li>UnitTypeEvent.SpellFinish</li> <li>UnitTypeEvent.SpellFinishOn</li> <li>UnitTypeEvent.StacksItem</li> <li>UnitTypeEvent.StartsBeingConstructed</li> <li>UnitTypeEvent.StartsBeingTrained</li> <li>UnitTypeEvent.StartsConstruction</li> <li>UnitTypeEvent.StartsResearch</li> <li>UnitTypeEvent.StartsTraining</li> <li>UnitTypeEvent.StartsUpgrade</li> <li>UnitTypeEvent.Summons</li> <li>UnitTypeEvent.UsesItem</li> </ul>"},{"location":"wcsharp/libraries/events/player-unit-events/#defining-custom-events","title":"Defining custom events","text":"<p>Custom events are created using <code>PlayerUnitEvents.AddCustomEvent</code>. For example, the custom event equivalent of <code>UnitTypeEvent.Kills</code> would be: <code>AddCustomEvent(EVENT_PLAYER_UNIT_DEATH, \"SomeIdentifier\", () =&gt; GetUnitTypeId(GetKillingUnit()))</code>. You can then use \"SomeIdentifier\" to register any number of events to this custom event. Absolute worth it if you want to register multiple events to the same type of filer! There is no performance difference between an event predefined and one that is custom defined.</p> <ul> <li><code>PlayerUnitEvents.Register(identifier, action, filterTypeId)</code> - The same as above, but the identifier refers to a custom event that was added using <code>AddCustomEventFilter</code>.</li> <li><code>PlayerUnitEvents.Unregister(identifier, filterTypeId)</code> - The same as above, but the identifier refers to a custom event that was added using <code>AddCustomEventFilter</code>. Due to quirks of the C# to Lua conversion, you cannot refer directly to WC3 natives when adding custom event filters. They must be enclosed in either a method or a lambda.</li> </ul> <p>These WILL work: <pre><code>PlayerUnitEvents.AddCustomEventFilter(EVENT_PLAYER_UNIT_TRAIN_START, \"UnitTypeStartsBeingTrained\", () =&gt; GetTrainedUnitType());\nPlayerUnitEvents.AddCustomEventFilter(EVENT_PLAYER_UNIT_TRAIN_START, \"UnitTypeStartsBeingTrained\", MyFilterMethod);\n\nstatic int MyFilterMethod()\n{\n    return GetTrainedUnitType();\n}\n</code></pre> This WILL NOT work: <pre><code>PlayerUnitEvents.AddCustomEventFilter(EVENT_PLAYER_UNIT_TRAIN_START, \"UnitTypeStartsBeingTrained\", GetTrainedUnitType);\n</code></pre></p>"},{"location":"wcsharp/libraries/json-convert/","title":"WCSharp.JsonConvert","text":"<p>Use of this package requires that the compilers IsExportMetadata property is set to true.</p> <p>Although probably not directly useful to the average map maker, JsonConvert is the backbone for various other systems such as WCSharp.SaveLoad, WCSharp.Sync and WCSharp.DateTime.</p> <p>WCSharp.JsonConvert allows you to serialize and deserialize generic classes into JSON format and back. This is used by WCSharp.SaveLoad and WCSharp.Sync to easily store or send complex data formats without requiring users to define additional logic.</p> <p>By using this format, nested data is also supported, for example:</p> <pre><code>public class First\n{\n    public int A { get; set; }\n    public Second B { get; set; }\n}\npublic class Second\n{\n    public string C { get; set; }\n    public List&lt;Third&gt; D { get; set; }\n}\npublic class Third\n{\n    public float E { get; set; }\n    public Dictionary&lt;int, Fourth&gt; F { get; set; }\n}\npublic class Fourth\n{\n    public int G { get; set; }\n}\n</code></pre> <p>This structure is fully supported, for example, the below code:</p> <pre><code>var first = new First\n{\n    A = 5,\n    B = new Second\n    {\n        C = \"SecondString\",\n        D = new List&lt;Third&gt;\n        {\n            new Third\n            {\n                E = 3.14f,\n                F = new Dictionary&lt;int, Fourth&gt;\n                {\n                    { 42, new Fourth{ G = -7 } },\n                    { -17, new Fourth{ G = 55 } }\n                }\n            }\n        }\n    }\n};\nConsole.WriteLine(JsonConvert.Serialize(first));\n</code></pre> <p>This will output <code>{\"B\":{\"D\":[{\"F\":{\"-17\":{\"G\":55},\"42\":{\"G\":-7}},\"E\":3.14}],\"C\":\"SecondString\"},\"A\":5}</code>, or with indentation (it currently always outputs non-indented JSON):</p> <pre><code>{\n    \"B\":{\n        \"D\":[\n            {\n                \"F\":{\n                    \"-17\":{\n                        \"G\":55\n                    },\n                    \"42\":{\n                        \"G\":-7\n                    }\n                },\n                \"E\":3.14\n            }\n        ],\n        \"C\":\"SecondString\"\n    },\n    \"A\":5\n}\n</code></pre> <p>Note that attributes are not supported, which means that properties are always serialized/deserialized according to their exact property definitions.</p> <p>For a more Warcraft III related example, you can check out this Save/Load example.</p>"},{"location":"wcsharp/libraries/json-convert/supported-formats/","title":"JsonFormat Supported Formats","text":"<p>Use of this package requires that the compilers IsExportMetadata property is set to true.</p> <p>The following formats are supported:</p> <ul> <li>All primitives (bool, int, etc.)</li> <li>Strings</li> <li>Enums</li> <li>Arrays, of which the element type must be a supported format</li> <li>Classes that implement <code>IDictionary&lt;,&gt;</code>, of which the key type must be a primitive or a string, and the value type must be a supported format</li> <li>Classes that implement <code>ICollection&lt;&gt;</code>, of which the value type must be a supported format.</li> <li>All other classes will be serialized/deserialized according to public properties. The types of all public properties must be a supported format. Note that get or set only properties are not supported and will result in an error.</li> </ul> <p>Furthermore, note that all classes must have a parameterless constructor, including those derived from <code>IDictionary&lt;,&gt;</code> and <code>ICollection&lt;&gt;</code>. Additionally, <code>KeyValuePair&lt;,&gt;</code> cannot be (de)serialized outside of their implicit occurance within dictionaries due to how they are implemented within CSharpLua.</p> <p>Finally, there is special support for classes that implement a public static <code>Serialize</code> and <code>Deserialize</code> method. These methods are used to (de)serialize a class to and from a string representation. Within WCSharp, <code>WcDateTime</code> and <code>WcTimeSpan</code> both have these methods, and can therefore be (de)serialized despite lacking a parameterless constructor. For example, the below code illustrates how this is implemented in WcDateTime.cs:</p> <pre><code>public static WcDateTime Deserialize(string @string)\n{\n    if (int.TryParse(@string, out var seconds))\n    {\n        return new WcDateTime(seconds);\n    }\n\n    return null;\n}\n\npublic static string Serialize(WcDateTime wcDateTime)\n{\n    return wcDateTime.seconds.ToString();\n}\n</code></pre> <p>Since this approach has the class itself create a new instance, classes which implement a public static <code>Serialize</code> and <code>Deserialize</code> method do not require a parameterless constructor.</p>"},{"location":"wcsharp/libraries/missiles/","title":"WCSharp.Missiles","text":"<p>The missile system offers the following features:</p> <ul> <li>Automatically manages any number of missiles on the whole map</li> <li>Offers various different types of missiles, such as arcing, curved, orbital or momentum based missiles</li> <li>Automatically handles things such as the target dying or hitting the edge of the map</li> <li>Can be extended with custom code on events such as impact or collision to perform any desired behaviour</li> </ul>"},{"location":"wcsharp/libraries/missiles/#usage","title":"Usage","text":"<p>The missile system is implemented in a manner similar to the buff system. To create any new missile, you will first want to create a new class, and implement one of the missile subtypes. For example, BasicMissile:</p> <pre><code>public class TestMissile : BasicMissile\n{\n\n}\n</code></pre> <p>Next, use the ALT+Enter combination while selecting the class name to create one of the required constructors. The one that you'll want to use will likely change depending on the type of missile that you're firing. Doing so may give you something like this:</p> <pre><code>public class TestMissile : BasicMissile\n{\n    public TestMissile(unit caster, unit target) : base(caster, target)\n    {\n    }\n}\n</code></pre> <p>Next we can fill some stuff in to create a functional missile:</p> <pre><code>public class TestMissile : BasicMissile\n{\n    public TestMissile(unit caster, unit target) : base(caster, target)\n    {\n        Speed = 600;\n        Arc = 0.3f;\n        EffectString = @\"Abilities\\Weapons\\FireBallMissile\\FireBallMissile.mdl\";\n        EffectScale = 1.0f;\n    }\n\n    public override void OnImpact()\n    {\n        // Deal damage to the target!\n    }\n}\n</code></pre> <p>Finally, to launch this missile, all we need to do is this:</p> <pre><code>var caster = GetTriggerUnit();\nvar target = GetSpellTargetUnit();\nvar missile = new TestMissile(caster, target)\n{\n    CasterHeightOffset = 50.0f\n    TargetHeightOffset = 50.0f\n}\nMissileSystem.Add(missile);\n</code></pre> <p>Properties can be set in either the constructor or via the public properties. I personally recommend using the constructor, as that'll make it easier to re-use the missile in other segments of the code without having to re-do those assignments. Note that, unless Caster/TargetHeightOffset are defined, the projectile will originate from/aim at the ground, which will likely look weird if fired by or directed at a unit.</p> <p>As the missile is its own class, it is easily extendable and usable in various ways.  For example, instead of always having the effect scale be the same, it can be based on the level of the ability.</p>"},{"location":"wcsharp/libraries/missiles/#type-overview","title":"Type overview","text":"<p>There are 5 missile types defined that each behave in a different manner. You can use any given type based on the trajectory that you want your missile to fly. Currently, the following types of missiles exist:</p> <ul> <li>BasicMissile - This is the most basic missile type. A simple location/unit A to location/unit B with an optional arc.</li> <li>CurveMissile- In this class you can combine the arc with a curve. What this means is that you can make the arc go e.g. sideways or diagonal. For example, setting Arc = 0.3f and Curve = 90 will give you a boomerang! Note that if you do not use the Curve property, you should use BasicMissile instead, as it offers the same functionality at much greater performance.</li> <li>HomingMissile - This is a missile that homes in on targets by travelling at a fixed speed and turning at a fixed rate. This essentially gives you a missile that you can side step to dodge, but will attempt to correct its course to ensure it hits. If it misses, it will turn around and attempt again (note that it can get stuck going in circles).</li> <li>MomentumMissile - This is a missile that homes in on targets by accelerating towards the target at a fixed acceleration speed. It will attempt to make intelligent adjustments to its course by essentially \"overcompensating\" in the direction that the target is, compared to the direction that it is currently flying at. If it misses, it will decelerate and go in the opposite direction.</li> <li>OrbitalMissile - This is a missile that will orbit the given target unit or location. The speed can be set either in units per second, or orbital period.</li> </ul>"},{"location":"wcsharp/libraries/missiles/#events","title":"Events","text":"Name Description OnImpact Override this method if your missile has an impact effect. The Active property is automatically set to false prior to calling this method. If you do not want the missile to end, you need to set Active back to true. OnPeriodic Override this method if your missile has a periodic effect. For this to be active, the Interval property must be greater than 0. OnCollision Override this method if your missile has an effect that should trigger when colliding with another unit. For this to be active, CollisionRadius must be greater than 0. Note that there is no filter on this collision. This is called whenever it collides with anything not in the TargetsHit property. Before this method is called, the unit is added to TargetsHit. OnDispose Override this method if your missile has an effect that should trigger when it is destroyed for any reason."},{"location":"wcsharp/libraries/missiles/#properties","title":"Properties","text":"<p>Below is an overview of all the properties available on the various missile types. The \"required\" essentially details which one of these you should set on launch. It's technically never required to do so, as the system doesn't mind if a missile has e.g. 0 speed (or even negative), but this is just for easy look up to ensure that you set a new missile up properly, and remembering what important properties you might have forgotten.</p> Name Used by Required Description Active All No Inherited from IPeriodicDisposableAction. Set to false to disable and dispose. Speed All Yes The speed at which the missile will travel, expressed in units per second. SpeedPerTick All Yes The speed at which the missile will travel, expressed in units per tick. EffectString All Yes The effect string to use for the effect. Can be altered mid-flight and will be updated accordingly. Curve CurveMissile Yes Dictates the curve at which the arc will occur. Technically not required, but if unused, you should use BasicMissile instead for greater performance. TurnRate HomingMissile Yes Dictates the rate at which the missile can turn itself, expressed in degrees per second. Defaults to 0. TurnPeriod HomingMissile Yes Dictates the rate at which the missile can turn itself, expressed in seconds per rotation. Defaults to 0. TurnVelocityRad HomingMissile Yes Dictates the rate at which the missile can turn itself, expressed in degrees per second. Defaults to 0. Acceleration MomentumMissile Yes The acceleration speed of the MomentumMissile, in units per second. Acceleration MaximumSpeed Yes The maximum speed of the MomentumMissile, in units per second. Note that you cannot set the speed to higher than the maximum speed. Range OrbitalMissile Yes The range at which the missile will orbit from the target in units. OrbitalPeriod OrbitalMissile Yes Defines the orbit period in seconds. OrbitalVelocity OrbitalMissile Yes Defines the orbit period in radians per tick. Mode All No The current flight mode of the missile. Each missile type has different flight modes, typically for handling terrain height. In most cases, the default will be preferred. EffectScale All No The scale of the effect. Can be altered mid-flight and will be updated accordingly. Defaults to 1. ImpactLeeway All No Can be used to increase the distance from which the missile can impact the target. Defaults to 0. Interval All No Determines how frequently the missile will run the OnPeriodic method. Disabled if 0 (default). CollisionSize All No Will trigger OnCollision for any units that come within the given range of the missile. Disabled if 0 (default). CasterLaunchZ All No Functionally identical to \"Art - Projectile Launch - Z\". TargetImpactZ All No Functionally identical to \"Art - Projectile Impact - Z\". Caster All No* The unit that created this missile. CastingPlayer All No* The owner (of the unit) that created this missile. Does NOT automatically update if the caster changes owner. CasterX All No* The X coordinate from which this missile was launched. CasterY All No* The Y coordinate from which this missile was launched. CasterZ All No* The Z coordinate from which this missile was launched. Target All No* The unit that created this missile. TargetPlayer All No* The owner (of the unit) targeted by this missile. Does NOT automatically update if the target changes owner. TargetX All No* The X coordinate which this missile is targeting. Automatically updated while the target is alive. TargetY All No* The Y coordinate which this missile is targeting. Automatically updated while the target is alive. TargetZ All No* The Z coordinate which this missile is targeting. Automatically updated while the target is alive. MissileX All No The current X coordinate of the missile. MissileY All No The current Y coordinate of the missile. MissileZ All No The current Z coordinate of the missile. Yaw All No The current yaw of the missile in degrees. Pitch All No The current pitch of the missile in degrees. Roll All No The current roll of the missile in degrees. YawRad All No The current yaw of the missile in radians. PitchRad All No The current pitch of the missile in radians. RollRad All No The current roll of the missile in radians. CurrentAngle All No The current angle of the missile in degrees, identical to yaw, just in layman's terms. SpinPeriod All No The amount of seconds it takes for the missile to spin once. Defaults to 0 (default). SpinVelocityRad All No The velocity of the spin in radians per tick. InitialAngle HomingMissile No The initial angle to use for the HomingMissile. Can be left at null to use the angle to the target. InitialAngle MomentumMissile No The initial angle to use for the MomentumMissile. Can be left at null to use the angle to the target. IsArcing BasicMissile No Whether the missile is currently performing an arcing motion. Can be used to re-enable the behavior if it was disabled due to rapid target movement. IsArcingOrCurving CurveMissile No Whether the missile is currently performing an arcing or curving motion. Can be used to re-enable the behavior if it was disabled due to rapid target movement. <p>*Technically required, but will be specified via the constructor.</p>"},{"location":"wcsharp/libraries/missiles/basic-missile/","title":"Basic Missile","text":"<p>The BasicMissile only implements the most basic behaviour for a missile and is generally very lightweight. The only unique property is <code>Arc</code>, which mirrors the in-game projectile arc.</p> <p>There are two special methods, <code>DisableArc</code> and <code>ReactiveArc</code>, which control the arcing behaviour (assuming the projectile has an arc that is not 0). If major changes in the targets position are encountered, the projectile can decide to disable its arc. If desired, you can re-enable it, although it may look strange if you do not handle it properly. In particular, this is useful when redirecting a missile to another target.</p> <p>A basic example of a missile that deals 100 damage to its target upon impact:</p> <pre><code>using WCSharp.Missiles;\nusing static War3Api.Common;\n\npublic class Arcing : BasicMissile\n{\n    public Arcing(unit caster, float targetX, float targetY) : base(caster, targetX, targetY)\n    {\n        CasterZ = 50;\n        TargetImpactZ = 50;\n        Speed = 600;\n        Arc = 0.3f;\n        EffectScale = 3.0f;\n        EffectString = @\"Abilities\\Spells\\Undead\\DeathCoil\\DeathCoilMissile.mdl\";\n    }\n\n    public override void OnImpact()\n    {\n        UnitDamageTarget(Caster, Target, 100, true, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNKNOWN, WEAPON_TYPE_WHOKNOWS);\n    }\n}\n</code></pre>"},{"location":"wcsharp/libraries/missiles/curve-missile/","title":"CurveMissile","text":"<p>The CurveMissile expands on the BasicMissile by providing an additional Curve property. This property adds an additional rotation to the arc of the projectile, allowing it to perform significantly more complex 3D trajectories. For example, setting the curve to <code>90</code> or <code>-90</code> will make it act like a boomerang, approaching the target from a horizontal arc instead of a vertical arc.</p> <p>There are two special methods, <code>DisableArc</code> and <code>ReactiveArc</code>, which control the arcing behaviour (assuming the projectile has an arc that is not 0). If major changes in the targets position are encountered, the projectile can decide to disable its arc. If desired, you can re-enable it, although it may look strange if you do not handle it properly. In particular, this is useful when redirecting a missile to another target.</p> <p>Below is a slightly advanced example to illustrate the complexity of missile patterns that you can create with this. This example will create 5 missiles that spread out behind the caster in a semi-circle. After 0.3 seconds, they will all change their direction to head straight to the target over 0.5s. This mimics Li-Ming's Magic Missile ability in Heroes of the Storm.</p> <pre><code>using WCSharp.Missiles;\nusing WCSharp.Util;\nusing static War3Api.Common;\n\npublic class Curving : CurveMissile\n{\n    public static void Initialise()\n    {\n        PlayerUnitEvents.Register(PlayerUnitEvent.SpellEffect, LaunchMissile, Constants.ABILITY_CURVING_MISSILE);\n    }\n\n    private static void LaunchMissile()\n    {\n        for (var i = 0; i &lt; 5; i++)\n        {\n            var missile = new Curving(GetTriggerUnit(), GetSpellTargetX(), GetSpellTargetY())\n            {\n                Curve = -90 + (45 * i)\n            };\n            MissileSystem.Add(missile);\n        }\n    }\n\n    public Curving(unit caster, float targetX, float targetY) : base(caster, targetX, targetY)\n    {\n        CasterZ = 50;\n        TargetImpactZ = 50;\n        Speed = -400;\n        Arc = 1.0f;\n        Interval = 0.3f;\n        EffectString = @\"Abilities\\Weapons\\Dryadmissile\\Dryadmissile.mdl\";\n    }\n\n    public override void OnPeriodic()\n    {\n        DisableArc();\n        Speed = Util.DistanceBetweenPoints(MissileX, MissileY, TargetX, TargetY) * 2;\n        Interval = 0;\n    }\n}\n</code></pre>"},{"location":"wcsharp/libraries/missiles/homing-missile/","title":"Homing Missile","text":"<p>HomingMissile adds the following properties:</p> Name Description TurnRate The rate at which the missile can turn in degrees per second. InitialAngle The initial angle in degrees. If left at null, will default to the angle towards the target. <p>The homing missile is similar to the momentum missile, but instead maintains a constant speed and constantly adjusts its angle such that it attempts to fly towards the target in a straight line. It is limited by this according to its <code>TurnRate</code>. Note that homing missiles can end up infinitely circling their target, as they do not try to account for the turning circle towards the target when adjusting their angle. For that reason, I recommend creating homing missiles with properties such as a large collision radius, a timed explosion or an increased <code>ImpactLeeway</code>.</p> <p>A basic example of a homing projectile that will home towards the target and explode upon colliding with the first enemy unit in a 250 radius:</p> <pre><code>using WCSharp.Missiles;\nusing static War3Api.Common;\n\npublic class Homing : HomingMissile\n{\n    public Homing(unit caster, unit target) : base(caster, target)\n    {\n        CasterZ = 50;\n        TargetImpactZ = 50;\n        Speed = 800;\n        TurnRate = 90;\n        Roll = 90;\n        EffectScale = 1.0f;\n        EffectString = @\"Abilities\\Weapons\\GlaiveMissile\\GlaiveMissile.mdl\";\n        CollisionRadius = 250;\n    }\n\n    public override void OnCollision(unit unit)\n    {\n        if (IsUnitEnemy(unit, CastingPlayer))\n        {\n            UnitDamageTarget(Caster, Target, 100, true, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNKNOWN, WEAPON_TYPE_WHOKNOWS);\n            Active = false;\n        }\n    }\n}\n</code></pre>"},{"location":"wcsharp/libraries/missiles/momentum-missile/","title":"MomentumMissile","text":"<p>MomentumMissile adds the following properties:</p> Name Description InitialAngle The initial angle in degrees. If left at null, will default to the angle towards the target. Acceleration The acceleration in units per second. MaximumSpeed The maximum speed in units per second. <p>The momentum missile is similar to the homing missile, but instead constantly attempts to accelerate towards the target. For example, if a unit blinks behind a momentum missile that is heading straight towards him, the missile will gradually slow down, and eventually turn to fly in the opposite direction. If the unit is fast enough/the missiles acceleration is slow enough, units can also sidestep the projectile, resulting in a similar outcome. Internally, it attempts to overcompensate its acceleration angle slightly to better adjust for changes in position by the target. This means that it will typically not accelerate/decelerate at the exact value defined by <code>Acceleration</code>, but makes it more reliable in tracking its target.</p> <p>The below example is a missile that will explode upon either impacting the target or after 5 seconds, dealing 100 damage to all nearby units.</p> <pre><code>using WCSharp.Missiles;\nusing WCSharp.Util;\nusing static War3Api.Common;\n\npublic class Momentum : MomentumMissile\n{\n    public Momentum(unit caster, unit target) : base(caster, target)\n    {\n        CasterZ = 50;\n        TargetImpactZ = 50;\n        Speed = 100;\n        MaximumSpeed = 1000;\n        Acceleration = 25;\n        InitialAngle = GetRandomReal(0, 360);\n        Roll = 90;\n        EffectString = @\"Abilities\\Weapons\\GlaiveMissile\\GlaiveMissile.mdl\";\n        Interval = 5.0f;\n    }\n\n    public override void OnImpact()\n    {\n        Explode();\n    }\n\n    public override void OnPeriodic()\n    {\n        Explode();\n    }\n\n    private void Explode()\n    {\n        var group = CreateGroup();\n        GroupEnumUnitsInRange(group, MissileX, MissileY, 300, null);\n        foreach (var unit in group.Enumerate())\n        {\n            UnitDamageTarget(Caster, unit, 100, true, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNKNOWN, WEAPON_TYPE_WHOKNOWS);\n        }\n        DestroyGroup(group);\n        Active = false;\n    }\n}\n</code></pre>"},{"location":"wcsharp/libraries/missiles/orbital-missile/","title":"OrbitalMissile","text":"<p>OrbitalMissile adds the following properties:</p> Name Description Speed This property behaves differently for orbital missiles. It defines a speed in units per second (negative to go clockwise). If you want to define speed in how long it takes to orbit once, use <code>OrbitalPeriod</code> instead. Range The distance at which the OrbitalMissile orbits from the origin. The speed of the missile after a range adjustment is determined by whether it was set via Speed or OrbitalPeriod. OrbitalPeriod The amount of time it takes to make one rotation in seconds. Use negative values to go clockwise. This can be used instead ofSpeed, and will ensure a consistent orbital period through Range adjustments. InitialAngle The initial angle in degrees at which this missile is created. If left at null, will use a random angle. <p>The orbital missile will orbit the target at the desired range. Unlike other missiles, it cannot impact the target.</p> <p>Below is a slightly more advanced example of an orbital missile. This missile completes an orbit once every 4 seconds at a range of 600, and collides with enemy units in a 150 radius. Targets hit are stored in a list and removed from TargetsHit after 1 second, allowing them to be collided with again via <code>OnCollision</code>.</p> <pre><code>using System.Collections.Generic;\nusing WCSharp.Missiles;\nusing WCSharp.Utils.Extensions;\nusing static War3Api.Common;\n\npublic class Orbital : OrbitalMissile\n{\n    private class UnitHit\n    {\n        public float Age { get; set; }\n        public unit Unit { get; }\n\n        public UnitHit(unit unit)\n        {\n            Unit = unit;\n        }\n    }\n\n    private readonly List&lt;UnitHit&gt; targetsHitCooldown = new List&lt;UnitHit&gt;();\n\n    public Orbital(unit caster, unit target) : base(caster, target)\n    {\n        TargetImpactZ = 50;\n        EffectScale = 1.0f;\n        EffectString = @\"Abilities\\Weapons\\GlaiveMissile\\GlaiveMissile.mdl\";\n        CollisionRadius = 150;\n        Range = 600;\n        OrbitalPeriod = 4.0f;\n        Interval = PeriodicEvents.SYSTEM_INTERVAL;\n    }\n\n    public override void OnCollision(unit unit)\n    {\n        if (IsUnitEnemy(unit, CastingPlayer))\n        {\n            UnitDamageTarget(Caster, Target, 100, true, false, ATTACK_TYPE_CHAOS, DAMAGE_TYPE_UNKNOWN, WEAPON_TYPE_WHOKNOWS);\n            this.targetsHitCooldown.Add(new UnitHit(unit));\n        }\n    }\n\n    public override void OnPeriodic()\n    {\n        this.targetsHitCooldown.IterateWithRemoval(cooldown =&gt;\n        {\n\n            cooldown.Age += PeriodicEvents.SYSTEM_INTERVAL;\n            if (cooldown.Age &gt;= 1)\n            {\n                TargetsHit.Remove(cooldown.Unit);\n                return false;\n            }\n\n            return true;\n        });\n    }\n}\n</code></pre> <p>Please see Utils for an explanation regarding the IterateWithRemoval method.</p>"},{"location":"wcsharp/libraries/save-load/","title":"WCSharp.SaveLoad","text":"<p>Use of this package requires that the compilers IsExportMetadata property is set to true. If you want a non-metadata reliant version, you can still use v1. However, note that v2 is not backwards compatible, meaning you cannot upgrade from v1 to v2 without all existing saves becoming invalid.</p> <p>The save system is a powerful system that provides the following features:</p> <ul> <li>Automatic saving and loading of complete classes</li> <li>Supports any number of save slots</li> <li>Automatically handles synchronisation of saved data</li> <li>Protects save files from tampering via hashcodes, optionally including the playername</li> <li>Each save system is its own instance, allowing multiple save formats and systems to be active on a single map</li> </ul>"},{"location":"wcsharp/libraries/save-load/#usage","title":"Usage","text":"<p>Version 2 of WCSharp.SaveLoad is backed by WCSharp.JsonConvert package, allowing it to save generic and complex data structures, including nested structures. The full scale of just what you can save is better explained in JsonConvert's supported formats and the Save/Load Example.</p> <p>Along with adding the capability of saving virtually any data structure, v2 also allows for the management of multiple save systems. Why is this useful? Well, using it you can interact with a variety of different saves within a single map, so that you can e.g. have a save file that is for the specific map, but also a save file that is shared between multiple maps.</p> <p>To set up a new SaveSystem, you need to supply it with a <code>SaveSystemOptions</code> like this:</p> <pre><code>new SaveSystem&lt;MySave&gt;(new SaveSystemOptions\n{\n    SaveFolder = \"MySaveFolder\",\n    ...\n});\n</code></pre> <p>The following properties are defined on <code>SaveSystemOptions</code>:</p> Name Description Hash1 Must be greater than 0. It is recommended to pick a large prime number. Hash2 Must be greater than 0. It is recommended to pick a large prime number. Salt May not be empty. The salt to use on the string. You can just type or generate something random. Around 16 characters is sufficient. SaveFolder May not be empty. The folder in which to store the saves. BindSavesToPlayerName Whether saves are bound to the name of the player. If true, saves will have the player name contained in the filename, and upon loading this will be matched with the current player's name. Suffix Optional. The given string will be added to the filename of any save stored. Base64Provider Optional. The save is encoded in Base64, if you want, you can provide a custom Base64 provider to effectively scramble the save. This does not change much in terms of protection, but makes it harder for people to inspect save files. <p>More information on these properties can be found through IntelliSense within Visual Studio.</p> <p>Finally, interaction with saves is primarily done via the <code>Save</code> and <code>Load</code> methods, as well as the <code>OnSaveLoaded</code> event. For details on their usage, please check the Save/Load Example.</p>"},{"location":"wcsharp/libraries/save-load/example/","title":"Save/Load Example","text":"<p>Use of this package requires that the compilers IsExportMetadata property is set to true.</p> <p>This page illustrates a more complex example of how you may want to save/load data in a map, and showcases the strength of WCSharp's save/load system.</p> <p>In this case, we will design a save file for a hero survival map. Each hero will have its own progression that is individually tracked. Since the save/load system is backed by the WCSharp.JsonConvert package, we can save nested data, as well as dictionary structures. This allows us to very easily create a structure with which we can save separate data for all heroes.</p> <p>To start off, lets define an enum with 3 heroes that the player:</p> <pre><code>public enum Hero\n{\n    Archmage = 1,\n    Blademaster = 2,\n    DemonHunter = 3\n}\n</code></pre> <p>It's important to give the enums an integer value, as the values that these enums map to should be consistent across different compilations of the same map. Instead of just \u00bd/3, you could also use e.g. the unit type IDs so you can easily convert between them.</p> <p>Anyway, now that we have this enum, we can set up a dictionary mapping these enums to our hero data:</p> <pre><code>using System.Collections.Generic;\nusing WCSharp.DateTime;\n\npublic class HeroData\n{\n    public int Level { get; set; }\n    public float Xp { get; set; }\n    public int Kills { get; set; }\n    public int Wins { get; set; }\n    public int Losses { get; set; }\n    public WcDateTime LastPlayed { get; set; }\n}\n\npublic class MySave\n{\n    public Dictionary&lt;Hero, HeroData&gt; Heroes { get; set; }\n}\n</code></pre> <p>With this we already have a powerful structure. With two classes and a single dictionary, we can store level, xp, kills, wins and losses for each hero, without needing to concern ourselves with avoiding name conflicts or anything like that. We're even using DateTime to store when the player last played that hero!</p> <p>We could also store more information outside of the <code>Heroes</code> dictionary if we want, but for now lets move on to actually turning this into something we can save and load. The first step is very easy, we just need to make <code>MySave</code> extend the <code>Saveable</code> class like this:</p> <pre><code>using System.Collections.Generic;\nusing WCSharp.SaveLoad;\n\npublic class MySave : Saveable\n{\n    public Dictionary&lt;Hero, HeroData&gt; Heroes { get; set; }\n}\n</code></pre> <p>We don't need to add anything else, just adding the <code>: Saveable</code> will add all we need, namely methods to get/set the player and save slot of this save.</p> <p>Now in order to easily interact with all our saves, lets create a static class to manage them that other components can easily reach:</p> <pre><code>using System.Collections.Generic;\nusing WCSharp.SaveLoad;\nusing WCSharp.Util;\n\npublic static class SaveManager\n{\n    public static Dictionary&lt;player, MySave&gt; SavesByPlayer { get; } = new Dictionary&lt;player, MySave&gt;();\n    private static SaveSystem&lt;MySave&gt; saveSystem;\n\n    public static void Initialize()\n    {\n        // Do not just copy/paste these options, you should pick your own hash and salt values\n        // You can use IntelliSense to get more information about the options\n        // Just know that Hash1, Hash2, Salt and SaveFolder are required\n        saveSystem = new SaveSystem&lt;MySave&gt;(new SaveSystemOptions\n        {\n            Hash1 = 775807,\n            Hash2 = 456023,\n            Salt = \"ZSLJ96ED6sPwYkQM\",\n            BindSavesToPlayerName = true,\n            SaveFolder = \"MyHeroSurvivalMap\"\n        });\n\n        saveSystem.OnSaveLoaded += SaveManager_OnSaveLoaded;\n\n        foreach (var player in Util.EnumeratePlayers())\n        {\n            saveSystem.Load(player);\n        }\n    }\n\n    public static void SaveManager_OnSaveLoaded(MySave save, LoadResult loadResult)\n    {\n        SavesByPlayer[save.GetPlayer()] = save;\n\n        // If the load result is anything except success, the save will be a newly created object\n        if (loadResult != LoadResult.Success)\n        {\n            // You can also just set the default value of the property to this.\n            // This is just to illustrate why you may want to know when it is an empty save,\n            // as then things like the heroes dictionary will not be created or filled.\n            save.Heroes = new Dictionary&lt;Hero, HeroData&gt;();\n        }\n        // Extension method for determining whether the load result is any of the failed states\n        if (loadResult.Failed())\n        {\n            Console.WriteLine(\"An existing save failed to load correctly!\");\n        }\n    }\n\n    public static void Save(MySave save)\n    {\n        saveSystem.Save(save);\n    }\n}\n</code></pre> <p>Now once we call <code>SaveManager.Initialize</code>, it will fetch the save files on save slot 1 for all players and return them to you via the <code>SaveManager_OnSaveLoaded</code> method, which then stores them in a dictionary so that other components can reach them. If the player does not have a save file, it will return a new instance of <code>MySave</code> and indicate that this happened via the <code>isEmptySave</code>, in case you need to perform special steps for new save files.</p> <p>Now once the map completes, we can update and store our data something like this:</p> <pre><code>var save = SaveManager.SavesByPlayer[currentPlayer];\nif (!save.Heroes.TryGetValue(pickedHero, out var heroData))\n{\n    heroData = new HeroData();\n    save.Heroes[pickedHero] = heroData;\n}\nheroData.Level = updatedLevel;\nheroData.Xp = updatedXp;\nheroData.Wins++;\nheroData.Kills += killsThisGame;\nheroData.LastPlayed = currentTime;\nSaveManager.Save(save);\n</code></pre> <p>And that's it! This is all you need to set up a basic save/load behaviour and save/load just about any data you might be interested in. Note that you will probably want to expand this example a bit further by e.g. ensuring that all save files are loaded before the map starts properly, or ensuring in some way that your components don't try to interact with a save for a player that it doesn't have.</p>"},{"location":"wcsharp/libraries/save-load/storage-space/","title":"Save/Load Storage Space","text":"<p>Use of this package requires that the compilers IsExportMetadata property is set to true.</p> <p>In a nutshell, the save/load system uses some curious WarCraft III interactions to store a file on disk, and in the next game we can set tooltips to previously defined values using this file. This is a bit of a convoluted approach, but it's the best we have right now.</p> <p>The use of ability tooltips raises an issue though, since it means we need to have a sufficient number of them to be able to load all the data. By default, WCSharp defines 10 of them, which allows us to save a JSON of around 1500 characters before we run out of space. This will be more than enough for most use cases, but in case you exceed 50% of that, the system will give out a warning. Furthermore, exceeding the limit will cause the system to refuse to save entirely.</p> <p>Raising this limit is not hard, however. By default, the following IDs are defined:</p> <pre><code>1097690227, // Amls\n1097359726, // Ahan\n1098018659, // Aroc\n1097689443, // Amic\n1097689452, // Amil\n1097034854, // Aclf\n1097035111, // Acmg\n1097098598, // Adef\n1097099635, // Adis\n1097228916, // Afbt\n</code></pre> <p>You can extend this list by calling <code>SaveSystem&lt;MySaveable&gt;.AddAbilityId(&lt;integer&gt;);</code>. You can use this page to get the integer values of ability codes, or alternatively just use the built-in <code>FourCC</code> method.</p> <p>The default list is a number of Human abilities, and for everyone's convenience I've included the remaining Human abilities below. Simply replace <code>&lt;MySaveable&gt;</code> with whatever Saveable implementation you are using. If you need even more, I recommend starting from Orc abilities and continuing in the same manner.</p> <p>Note: Only use abilities which have a tooltip! Abilities such as \"Berserker Upgrade\" (Sbsk) will NOT work! WCSharp.SaveLoad 2.0.2 and later will attempt to detect when this occurs, but this detection will likely not work on non-English clients.</p> <pre><code>SaveSystem&lt;MySaveable&gt;.AddAbilityId(1097228907); // Afbk\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1097231467); // Aflk\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1097231457); // Afla\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1097300322); // Agyb\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1097233256); // Afsh\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1097360737); // Ahea\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1097362536); // Ahlh\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1097428582); // Ainf\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1097430643); // Aivs\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1097364073); // Ahri\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1097688166); // Amdf\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1097102451); // Adts\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1097363557); // Ahpe\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1097889894); // Apxf\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1097886841); // Aply\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1097364080); // Ahrp\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1095267425); // AHta\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1098083439); // Aslo\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1098084467); // Asps\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1098085480); // Asth\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1097364322); // Ahsb\nSaveSystem&lt;MySaveable&gt;.AddAbilityId(1097300342); // Agyv\n</code></pre>"},{"location":"wcsharp/libraries/save-load/v1/","title":"Save/Load v1","text":"<p>Warning</p> <p>This version of WCSharp.SaveLoad has been deprecated. For v2, see WCSharp.SaveLoad.</p> <p>IMPORTANT: The save/load system required several properties to be initialised! Please read on!</p> <p>The save system is a powerful system that provides the following features:</p> <ul> <li>Automatic saving and loading of any number of key-value pairs</li> <li>Supports any number of save slots</li> <li>Automatically handling synchronisation of data</li> <li>Protects save files from tampering via hashcodes, optionally including the playername</li> <li>Supports converting a save to a typed class for easier working with the data</li> </ul>"},{"location":"wcsharp/libraries/save-load/v1/#configuration","title":"Configuration","text":"<p>To configure the system, a total of 4 properties on the SaveSystem class need to be configured:</p> <ul> <li>Hash1</li> <li>Hash2</li> <li>SaveFolder</li> <li>BindSavesToPlayerName</li> </ul> <p>For information as to what these should be set to, please refer to the information provided by IntelliSense in Visual Studio.</p>"},{"location":"wcsharp/libraries/save-load/v1/#usage","title":"Usage","text":"<p>Before attempting to load any files, you need to attach an event listener to <code>SaveSystem.OnSaveLoaded</code>. You can simply type <code>SaveSystem.OnSaveLoaded +=</code> and then use ALT+Enter to automatically generate the following code:</p> <pre><code>SaveSystem.OnSaveLoaded += SaveSystem_OnSaveLoaded;\n\n...\n\nprivate static void SaveSystem_OnSaveLoaded(Save save)\n{\n}\n</code></pre> <p>Once we've set up the event listener, we can load a save file via <code>SaveSystem.Load(player, saveSlot)</code>. The system will automatically load in the save file, verify its validity, and synchronize it across all players. If no save file is found, or the save file is invalid (e.g. it has been tampered with), the event will produce an empty save file.</p> <p>Now that we have the Save class, we can use this to retrieve and store data. Note that all data is stored as text, but there are a number of methods to easily retrieve the desired type instead. However, converting the data and checking if the  is still a bit of a hassle to constantly check for keys being present. In order to make this easier, we can use a method to convert the save into a more easily manageable form. For this, we need a new class that extends the <code>Saveable</code> class to store our data. An example of this can be found below:</p> <pre><code>public class SaveData : Saveable\n{\n    public string HeroNameString { get; set; } = \"\";\n    public int LevelInt { get; set; }\n    public float ExperienceFloat { get; set; }\n}\n</code></pre> <p>We can receive an instance of this class, loaded with all of the data present in a save file, using the following method: <code>var saveData = save.Deserialize&lt;SaveData&gt;();</code>.</p> <p>Due to the restrictions on reflection in Lua, a number of conditions must be met for the properties on this class:</p> <ul> <li>Strings must be initialised to some non-null value, e.g. an empty string <code>\"\"</code>.</li> <li>Every property that should be saved/loaded needs to have its name suffixed with its type. You may add properties that are not suffixed to the class, but these will not be save/loaded automatically. The currently supported types are:<ul> <li>String  </li> <li>Byte  </li> <li>SByte  </li> <li>Char  </li> <li>Decimal  </li> <li>Double  </li> <li>Float  </li> <li>Int  </li> <li>UInt  </li> <li>Long  </li> <li>ULong  </li> <li>Short  </li> <li>UShort</li> </ul> </li> </ul> <p>Finally, for saving data to file, any class that extends the <code>Saveable</code> class has a simple <code>Save</code> function. Otherwise, you will need to use <code>SaveSystem.Save(save)</code>.</p>"}]}